(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([typeof document === "object" ? document.currentScript : undefined, {

"[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * @license React
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch(type){
            case REACT_FRAGMENT_TYPE:
                return "Fragment";
            case REACT_PROFILER_TYPE:
                return "Profiler";
            case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
            case REACT_SUSPENSE_TYPE:
                return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
                return "Activity";
        }
        if ("object" === typeof type) switch("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof){
            case REACT_PORTAL_TYPE:
                return "Portal";
            case REACT_CONTEXT_TYPE:
                return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
            case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                    return getComponentNameFromType(type(innerType));
                } catch (x) {}
        }
        return null;
    }
    function testStringCoercion(value) {
        return "" + value;
    }
    function checkKeyStringCoercion(value) {
        try {
            testStringCoercion(value);
            var JSCompiler_inline_result = !1;
        } catch (e) {
            JSCompiler_inline_result = !0;
        }
        if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
            return testStringCoercion(value);
        }
    }
    function getTaskName(type) {
        if (type === REACT_FRAGMENT_TYPE) return "<>";
        if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE) return "<...>";
        try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
        } catch (x) {
            return "<...>";
        }
    }
    function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
        return Error("react-stack-top-frame");
    }
    function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return !1;
        }
        return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
        }
        warnAboutAccessingKey.isReactWarning = !0;
        Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: !0
        });
    }
    function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {
        self = props.ref;
        type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type,
            key: key,
            props: props,
            _owner: owner
        };
        null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
            enumerable: !1,
            get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", {
            enumerable: !1,
            value: null
        });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: null
        });
        Object.defineProperty(type, "_debugStack", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugStack
        });
        Object.defineProperty(type, "_debugTask", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugTask
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
    }
    function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, debugStack, debugTask) {
        var children = config.children;
        if (void 0 !== children) if (isStaticChildren) if (isArrayImpl(children)) {
            for(isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)validateChildKeys(children[isStaticChildren]);
            Object.freeze && Object.freeze(children);
        } else console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else validateChildKeys(children);
        if (hasOwnProperty.call(config, "key")) {
            children = getComponentNameFromType(type);
            var keys = Object.keys(config).filter(function(k) {
                return "key" !== k;
            });
            isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
            didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = !0);
        }
        children = null;
        void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
        hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
        if ("key" in config) {
            maybeKey = {};
            for(var propName in config)"key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        children && defineKeyPropWarningGetter(maybeKey, "function" === typeof type ? type.displayName || type.name || "Unknown" : type);
        return ReactElement(type, children, self, source, getOwner(), maybeKey, debugStack, debugTask);
    }
    function validateChildKeys(node) {
        "object" === typeof node && null !== node && node.$$typeof === REACT_ELEMENT_TYPE && node._store && (node._store.validated = 1);
    }
    var React = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    Symbol.for("react.provider");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
        return null;
    };
    React = {
        "react-stack-bottom-frame": function(callStackForError) {
            return callStackForError();
        }
    };
    var specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = React["react-stack-bottom-frame"].bind(React, UnknownOwner)();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutKeySpread = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsxDEV = function(type, config, maybeKey, isStaticChildren, source, self) {
        var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
}();
}}),
"[project]/node_modules/next/dist/compiled/react/jsx-dev-runtime.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else {
    module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)");
}
}}),
"[project]/node_modules/next/dist/compiled/client-only/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
}}),
"[project]/node_modules/styled-jsx/dist/index/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
__turbopack_context__.r("[project]/node_modules/next/dist/compiled/client-only/index.js [app-client] (ecmascript)");
var React = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
function _interopDefaultLegacy(e) {
    return e && typeof e === 'object' && 'default' in e ? e : {
        'default': e
    };
}
var React__default = /*#__PURE__*/ _interopDefaultLegacy(React);
/*
Based on Glamor's sheet
https://github.com/threepointone/glamor/blob/667b480d31b3721a905021b26e1290ce92ca2879/src/sheet.js
*/ function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
var isProd = typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] !== "undefined" && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env && ("TURBOPACK compile-time value", "development") === "production";
var isString = function(o) {
    return Object.prototype.toString.call(o) === "[object String]";
};
var StyleSheet = /*#__PURE__*/ function() {
    function StyleSheet(param) {
        var ref = param === void 0 ? {} : param, _name = ref.name, name = _name === void 0 ? "stylesheet" : _name, _optimizeForSpeed = ref.optimizeForSpeed, optimizeForSpeed = _optimizeForSpeed === void 0 ? isProd : _optimizeForSpeed;
        invariant$1(isString(name), "`name` must be a string");
        this._name = name;
        this._deletedRulePlaceholder = "#" + name + "-deleted-rule____{}";
        invariant$1(typeof optimizeForSpeed === "boolean", "`optimizeForSpeed` must be a boolean");
        this._optimizeForSpeed = optimizeForSpeed;
        this._serverSheet = undefined;
        this._tags = [];
        this._injected = false;
        this._rulesCount = 0;
        var node = typeof window !== "undefined" && document.querySelector('meta[property="csp-nonce"]');
        this._nonce = node ? node.getAttribute("content") : null;
    }
    var _proto = StyleSheet.prototype;
    _proto.setOptimizeForSpeed = function setOptimizeForSpeed(bool) {
        invariant$1(typeof bool === "boolean", "`setOptimizeForSpeed` accepts a boolean");
        invariant$1(this._rulesCount === 0, "optimizeForSpeed cannot be when rules have already been inserted");
        this.flush();
        this._optimizeForSpeed = bool;
        this.inject();
    };
    _proto.isOptimizeForSpeed = function isOptimizeForSpeed() {
        return this._optimizeForSpeed;
    };
    _proto.inject = function inject() {
        var _this = this;
        invariant$1(!this._injected, "sheet already injected");
        this._injected = true;
        if (typeof window !== "undefined" && this._optimizeForSpeed) {
            this._tags[0] = this.makeStyleTag(this._name);
            this._optimizeForSpeed = "insertRule" in this.getSheet();
            if (!this._optimizeForSpeed) {
                if ("TURBOPACK compile-time truthy", 1) {
                    console.warn("StyleSheet: optimizeForSpeed mode not supported falling back to standard mode.");
                }
                this.flush();
                this._injected = true;
            }
            return;
        }
        this._serverSheet = {
            cssRules: [],
            insertRule: function(rule, index) {
                if (typeof index === "number") {
                    _this._serverSheet.cssRules[index] = {
                        cssText: rule
                    };
                } else {
                    _this._serverSheet.cssRules.push({
                        cssText: rule
                    });
                }
                return index;
            },
            deleteRule: function(index) {
                _this._serverSheet.cssRules[index] = null;
            }
        };
    };
    _proto.getSheetForTag = function getSheetForTag(tag) {
        if (tag.sheet) {
            return tag.sheet;
        }
        // this weirdness brought to you by firefox
        for(var i = 0; i < document.styleSheets.length; i++){
            if (document.styleSheets[i].ownerNode === tag) {
                return document.styleSheets[i];
            }
        }
    };
    _proto.getSheet = function getSheet() {
        return this.getSheetForTag(this._tags[this._tags.length - 1]);
    };
    _proto.insertRule = function insertRule(rule, index) {
        invariant$1(isString(rule), "`insertRule` accepts only strings");
        if (typeof window === "undefined") {
            if (typeof index !== "number") {
                index = this._serverSheet.cssRules.length;
            }
            this._serverSheet.insertRule(rule, index);
            return this._rulesCount++;
        }
        if (this._optimizeForSpeed) {
            var sheet = this.getSheet();
            if (typeof index !== "number") {
                index = sheet.cssRules.length;
            }
            // this weirdness for perf, and chrome's weird bug
            // https://stackoverflow.com/questions/20007992/chrome-suddenly-stopped-accepting-insertrule
            try {
                sheet.insertRule(rule, index);
            } catch (error) {
                if ("TURBOPACK compile-time truthy", 1) {
                    console.warn("StyleSheet: illegal rule: \n\n" + rule + "\n\nSee https://stackoverflow.com/q/20007992 for more info");
                }
                return -1;
            }
        } else {
            var insertionPoint = this._tags[index];
            this._tags.push(this.makeStyleTag(this._name, rule, insertionPoint));
        }
        return this._rulesCount++;
    };
    _proto.replaceRule = function replaceRule(index, rule) {
        if (this._optimizeForSpeed || typeof window === "undefined") {
            var sheet = typeof window !== "undefined" ? this.getSheet() : this._serverSheet;
            if (!rule.trim()) {
                rule = this._deletedRulePlaceholder;
            }
            if (!sheet.cssRules[index]) {
                // @TBD Should we throw an error?
                return index;
            }
            sheet.deleteRule(index);
            try {
                sheet.insertRule(rule, index);
            } catch (error) {
                if ("TURBOPACK compile-time truthy", 1) {
                    console.warn("StyleSheet: illegal rule: \n\n" + rule + "\n\nSee https://stackoverflow.com/q/20007992 for more info");
                }
                // In order to preserve the indices we insert a deleteRulePlaceholder
                sheet.insertRule(this._deletedRulePlaceholder, index);
            }
        } else {
            var tag = this._tags[index];
            invariant$1(tag, "old rule at index `" + index + "` not found");
            tag.textContent = rule;
        }
        return index;
    };
    _proto.deleteRule = function deleteRule(index) {
        if (typeof window === "undefined") {
            this._serverSheet.deleteRule(index);
            return;
        }
        if (this._optimizeForSpeed) {
            this.replaceRule(index, "");
        } else {
            var tag = this._tags[index];
            invariant$1(tag, "rule at index `" + index + "` not found");
            tag.parentNode.removeChild(tag);
            this._tags[index] = null;
        }
    };
    _proto.flush = function flush() {
        this._injected = false;
        this._rulesCount = 0;
        if (typeof window !== "undefined") {
            this._tags.forEach(function(tag) {
                return tag && tag.parentNode.removeChild(tag);
            });
            this._tags = [];
        } else {
            // simpler on server
            this._serverSheet.cssRules = [];
        }
    };
    _proto.cssRules = function cssRules() {
        var _this = this;
        if (typeof window === "undefined") {
            return this._serverSheet.cssRules;
        }
        return this._tags.reduce(function(rules, tag) {
            if (tag) {
                rules = rules.concat(Array.prototype.map.call(_this.getSheetForTag(tag).cssRules, function(rule) {
                    return rule.cssText === _this._deletedRulePlaceholder ? null : rule;
                }));
            } else {
                rules.push(null);
            }
            return rules;
        }, []);
    };
    _proto.makeStyleTag = function makeStyleTag(name, cssString, relativeToTag) {
        if (cssString) {
            invariant$1(isString(cssString), "makeStyleTag accepts only strings as second parameter");
        }
        var tag = document.createElement("style");
        if (this._nonce) tag.setAttribute("nonce", this._nonce);
        tag.type = "text/css";
        tag.setAttribute("data-" + name, "");
        if (cssString) {
            tag.appendChild(document.createTextNode(cssString));
        }
        var head = document.head || document.getElementsByTagName("head")[0];
        if (relativeToTag) {
            head.insertBefore(tag, relativeToTag);
        } else {
            head.appendChild(tag);
        }
        return tag;
    };
    _createClass(StyleSheet, [
        {
            key: "length",
            get: function get() {
                return this._rulesCount;
            }
        }
    ]);
    return StyleSheet;
}();
function invariant$1(condition, message) {
    if (!condition) {
        throw new Error("StyleSheet: " + message + ".");
    }
}
function hash(str) {
    var _$hash = 5381, i = str.length;
    while(i){
        _$hash = _$hash * 33 ^ str.charCodeAt(--i);
    }
    /* JavaScript does bitwise operations (like XOR, above) on 32-bit signed
   * integers. Since we want the results to be always positive, convert the
   * signed int to an unsigned by doing an unsigned bitshift. */ return _$hash >>> 0;
}
var stringHash = hash;
var sanitize = function(rule) {
    return rule.replace(/\/style/gi, "\\/style");
};
var cache = {};
/**
 * computeId
 *
 * Compute and memoize a jsx id from a basedId and optionally props.
 */ function computeId(baseId, props) {
    if (!props) {
        return "jsx-" + baseId;
    }
    var propsToString = String(props);
    var key = baseId + propsToString;
    if (!cache[key]) {
        cache[key] = "jsx-" + stringHash(baseId + "-" + propsToString);
    }
    return cache[key];
}
/**
 * computeSelector
 *
 * Compute and memoize dynamic selectors.
 */ function computeSelector(id, css) {
    var selectoPlaceholderRegexp = /__jsx-style-dynamic-selector/g;
    // Sanitize SSR-ed CSS.
    // Client side code doesn't need to be sanitized since we use
    // document.createTextNode (dev) and the CSSOM api sheet.insertRule (prod).
    if (typeof window === "undefined") {
        css = sanitize(css);
    }
    var idcss = id + css;
    if (!cache[idcss]) {
        cache[idcss] = css.replace(selectoPlaceholderRegexp, id);
    }
    return cache[idcss];
}
function mapRulesToStyle(cssRules, options) {
    if (options === void 0) options = {};
    return cssRules.map(function(args) {
        var id = args[0];
        var css = args[1];
        return /*#__PURE__*/ React__default["default"].createElement("style", {
            id: "__" + id,
            // Avoid warnings upon render with a key
            key: "__" + id,
            nonce: options.nonce ? options.nonce : undefined,
            dangerouslySetInnerHTML: {
                __html: css
            }
        });
    });
}
var StyleSheetRegistry = /*#__PURE__*/ function() {
    function StyleSheetRegistry(param) {
        var ref = param === void 0 ? {} : param, _styleSheet = ref.styleSheet, styleSheet = _styleSheet === void 0 ? null : _styleSheet, _optimizeForSpeed = ref.optimizeForSpeed, optimizeForSpeed = _optimizeForSpeed === void 0 ? false : _optimizeForSpeed;
        this._sheet = styleSheet || new StyleSheet({
            name: "styled-jsx",
            optimizeForSpeed: optimizeForSpeed
        });
        this._sheet.inject();
        if (styleSheet && typeof optimizeForSpeed === "boolean") {
            this._sheet.setOptimizeForSpeed(optimizeForSpeed);
            this._optimizeForSpeed = this._sheet.isOptimizeForSpeed();
        }
        this._fromServer = undefined;
        this._indices = {};
        this._instancesCounts = {};
    }
    var _proto = StyleSheetRegistry.prototype;
    _proto.add = function add(props) {
        var _this = this;
        if (undefined === this._optimizeForSpeed) {
            this._optimizeForSpeed = Array.isArray(props.children);
            this._sheet.setOptimizeForSpeed(this._optimizeForSpeed);
            this._optimizeForSpeed = this._sheet.isOptimizeForSpeed();
        }
        if (typeof window !== "undefined" && !this._fromServer) {
            this._fromServer = this.selectFromServer();
            this._instancesCounts = Object.keys(this._fromServer).reduce(function(acc, tagName) {
                acc[tagName] = 0;
                return acc;
            }, {});
        }
        var ref = this.getIdAndRules(props), styleId = ref.styleId, rules = ref.rules;
        // Deduping: just increase the instances count.
        if (styleId in this._instancesCounts) {
            this._instancesCounts[styleId] += 1;
            return;
        }
        var indices = rules.map(function(rule) {
            return _this._sheet.insertRule(rule);
        }) // Filter out invalid rules
        .filter(function(index) {
            return index !== -1;
        });
        this._indices[styleId] = indices;
        this._instancesCounts[styleId] = 1;
    };
    _proto.remove = function remove(props) {
        var _this = this;
        var styleId = this.getIdAndRules(props).styleId;
        invariant(styleId in this._instancesCounts, "styleId: `" + styleId + "` not found");
        this._instancesCounts[styleId] -= 1;
        if (this._instancesCounts[styleId] < 1) {
            var tagFromServer = this._fromServer && this._fromServer[styleId];
            if (tagFromServer) {
                tagFromServer.parentNode.removeChild(tagFromServer);
                delete this._fromServer[styleId];
            } else {
                this._indices[styleId].forEach(function(index) {
                    return _this._sheet.deleteRule(index);
                });
                delete this._indices[styleId];
            }
            delete this._instancesCounts[styleId];
        }
    };
    _proto.update = function update(props, nextProps) {
        this.add(nextProps);
        this.remove(props);
    };
    _proto.flush = function flush() {
        this._sheet.flush();
        this._sheet.inject();
        this._fromServer = undefined;
        this._indices = {};
        this._instancesCounts = {};
    };
    _proto.cssRules = function cssRules() {
        var _this = this;
        var fromServer = this._fromServer ? Object.keys(this._fromServer).map(function(styleId) {
            return [
                styleId,
                _this._fromServer[styleId]
            ];
        }) : [];
        var cssRules = this._sheet.cssRules();
        return fromServer.concat(Object.keys(this._indices).map(function(styleId) {
            return [
                styleId,
                _this._indices[styleId].map(function(index) {
                    return cssRules[index].cssText;
                }).join(_this._optimizeForSpeed ? "" : "\n")
            ];
        }) // filter out empty rules
        .filter(function(rule) {
            return Boolean(rule[1]);
        }));
    };
    _proto.styles = function styles(options) {
        return mapRulesToStyle(this.cssRules(), options);
    };
    _proto.getIdAndRules = function getIdAndRules(props) {
        var css = props.children, dynamic = props.dynamic, id = props.id;
        if (dynamic) {
            var styleId = computeId(id, dynamic);
            return {
                styleId: styleId,
                rules: Array.isArray(css) ? css.map(function(rule) {
                    return computeSelector(styleId, rule);
                }) : [
                    computeSelector(styleId, css)
                ]
            };
        }
        return {
            styleId: computeId(id),
            rules: Array.isArray(css) ? css : [
                css
            ]
        };
    };
    /**
   * selectFromServer
   *
   * Collects style tags from the document with id __jsx-XXX
   */ _proto.selectFromServer = function selectFromServer() {
        var elements = Array.prototype.slice.call(document.querySelectorAll('[id^="__jsx-"]'));
        return elements.reduce(function(acc, element) {
            var id = element.id.slice(2);
            acc[id] = element;
            return acc;
        }, {});
    };
    return StyleSheetRegistry;
}();
function invariant(condition, message) {
    if (!condition) {
        throw new Error("StyleSheetRegistry: " + message + ".");
    }
}
var StyleSheetContext = /*#__PURE__*/ React.createContext(null);
StyleSheetContext.displayName = "StyleSheetContext";
function createStyleRegistry() {
    return new StyleSheetRegistry();
}
function StyleRegistry(param) {
    var configuredRegistry = param.registry, children = param.children;
    var rootRegistry = React.useContext(StyleSheetContext);
    var ref = React.useState({
        "StyleRegistry.useState[ref]": function() {
            return rootRegistry || configuredRegistry || createStyleRegistry();
        }
    }["StyleRegistry.useState[ref]"]), registry = ref[0];
    return /*#__PURE__*/ React__default["default"].createElement(StyleSheetContext.Provider, {
        value: registry
    }, children);
}
function useStyleRegistry() {
    return React.useContext(StyleSheetContext);
}
// Opt-into the new `useInsertionEffect` API in React 18, fallback to `useLayoutEffect`.
// https://github.com/reactwg/react-18/discussions/110
var useInsertionEffect = React__default["default"].useInsertionEffect || React__default["default"].useLayoutEffect;
var defaultRegistry = typeof window !== "undefined" ? createStyleRegistry() : undefined;
function JSXStyle(props) {
    var registry = defaultRegistry ? defaultRegistry : useStyleRegistry();
    // If `registry` does not exist, we do nothing here.
    if (!registry) {
        return null;
    }
    if (typeof window === "undefined") {
        registry.add(props);
        return null;
    }
    useInsertionEffect({
        "JSXStyle.useInsertionEffect": function() {
            registry.add(props);
            return ({
                "JSXStyle.useInsertionEffect": function() {
                    registry.remove(props);
                }
            })["JSXStyle.useInsertionEffect"];
        // props.children can be string[], will be striped since id is identical
        }
    }["JSXStyle.useInsertionEffect"], [
        props.id,
        String(props.dynamic)
    ]);
    return null;
}
JSXStyle.dynamic = function(info) {
    return info.map(function(tagInfo) {
        var baseId = tagInfo[0];
        var props = tagInfo[1];
        return computeId(baseId, props);
    }).join(" ");
};
exports.StyleRegistry = StyleRegistry;
exports.createStyleRegistry = createStyleRegistry;
exports.style = JSXStyle;
exports.useStyleRegistry = useStyleRegistry;
}}),
"[project]/node_modules/styled-jsx/style.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = __turbopack_context__.r("[project]/node_modules/styled-jsx/dist/index/index.js [app-client] (ecmascript)").style;
}}),
"[project]/node_modules/qrcode.react/lib/esm/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "QRCodeCanvas": (()=>QRCodeCanvas),
    "QRCodeSVG": (()=>QRCodeSVG)
});
// src/index.tsx
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)");
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value
    }) : obj[key] = value;
var __spreadValues = (a, b)=>{
    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){
        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
};
var __objRest = (source, exclude)=>{
    var target = {};
    for(var prop in source)if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols) for (var prop of __getOwnPropSymbols(source)){
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];
    }
    return target;
};
;
// src/third-party/qrcodegen/index.ts
/**
 * @license QR Code generator library (TypeScript)
 * Copyright (c) Project Nayuki.
 * SPDX-License-Identifier: MIT
 */ var qrcodegen;
((qrcodegen2)=>{
    const _QrCode = class _QrCode {
        /*-- Constructor (low level) and fields --*/ // Creates a new QR Code with the given version number,
        // error correction level, data codeword bytes, and mask number.
        // This is a low-level API that most users should not use directly.
        // A mid-level API is the encodeSegments() function.
        constructor(version, errorCorrectionLevel, dataCodewords, msk){
            this.version = version;
            this.errorCorrectionLevel = errorCorrectionLevel;
            // The modules of this QR Code (false = light, true = dark).
            // Immutable after constructor finishes. Accessed through getModule().
            this.modules = [];
            // Indicates function modules that are not subjected to masking. Discarded when constructor finishes.
            this.isFunction = [];
            if (version < _QrCode.MIN_VERSION || version > _QrCode.MAX_VERSION) throw new RangeError("Version value out of range");
            if (msk < -1 || msk > 7) throw new RangeError("Mask value out of range");
            this.size = version * 4 + 17;
            let row = [];
            for(let i = 0; i < this.size; i++)row.push(false);
            for(let i = 0; i < this.size; i++){
                this.modules.push(row.slice());
                this.isFunction.push(row.slice());
            }
            this.drawFunctionPatterns();
            const allCodewords = this.addEccAndInterleave(dataCodewords);
            this.drawCodewords(allCodewords);
            if (msk == -1) {
                let minPenalty = 1e9;
                for(let i = 0; i < 8; i++){
                    this.applyMask(i);
                    this.drawFormatBits(i);
                    const penalty = this.getPenaltyScore();
                    if (penalty < minPenalty) {
                        msk = i;
                        minPenalty = penalty;
                    }
                    this.applyMask(i);
                }
            }
            assert(0 <= msk && msk <= 7);
            this.mask = msk;
            this.applyMask(msk);
            this.drawFormatBits(msk);
            this.isFunction = [];
        }
        /*-- Static factory functions (high level) --*/ // Returns a QR Code representing the given Unicode text string at the given error correction level.
        // As a conservative upper bound, this function is guaranteed to succeed for strings that have 738 or fewer
        // Unicode code points (not UTF-16 code units) if the low error correction level is used. The smallest possible
        // QR Code version is automatically chosen for the output. The ECC level of the result may be higher than the
        // ecl argument if it can be done without increasing the version.
        static encodeText(text, ecl) {
            const segs = qrcodegen2.QrSegment.makeSegments(text);
            return _QrCode.encodeSegments(segs, ecl);
        }
        // Returns a QR Code representing the given binary data at the given error correction level.
        // This function always encodes using the binary segment mode, not any text mode. The maximum number of
        // bytes allowed is 2953. The smallest possible QR Code version is automatically chosen for the output.
        // The ECC level of the result may be higher than the ecl argument if it can be done without increasing the version.
        static encodeBinary(data, ecl) {
            const seg = qrcodegen2.QrSegment.makeBytes(data);
            return _QrCode.encodeSegments([
                seg
            ], ecl);
        }
        /*-- Static factory functions (mid level) --*/ // Returns a QR Code representing the given segments with the given encoding parameters.
        // The smallest possible QR Code version within the given range is automatically
        // chosen for the output. Iff boostEcl is true, then the ECC level of the result
        // may be higher than the ecl argument if it can be done without increasing the
        // version. The mask number is either between 0 to 7 (inclusive) to force that
        // mask, or -1 to automatically choose an appropriate mask (which may be slow).
        // This function allows the user to create a custom sequence of segments that switches
        // between modes (such as alphanumeric and byte) to encode text in less space.
        // This is a mid-level API; the high-level API is encodeText() and encodeBinary().
        static encodeSegments(segs, ecl, minVersion = 1, maxVersion = 40, mask = -1, boostEcl = true) {
            if (!(_QrCode.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= _QrCode.MAX_VERSION) || mask < -1 || mask > 7) throw new RangeError("Invalid value");
            let version;
            let dataUsedBits;
            for(version = minVersion;; version++){
                const dataCapacityBits2 = _QrCode.getNumDataCodewords(version, ecl) * 8;
                const usedBits = QrSegment.getTotalBits(segs, version);
                if (usedBits <= dataCapacityBits2) {
                    dataUsedBits = usedBits;
                    break;
                }
                if (version >= maxVersion) throw new RangeError("Data too long");
            }
            for (const newEcl of [
                _QrCode.Ecc.MEDIUM,
                _QrCode.Ecc.QUARTILE,
                _QrCode.Ecc.HIGH
            ]){
                if (boostEcl && dataUsedBits <= _QrCode.getNumDataCodewords(version, newEcl) * 8) ecl = newEcl;
            }
            let bb = [];
            for (const seg of segs){
                appendBits(seg.mode.modeBits, 4, bb);
                appendBits(seg.numChars, seg.mode.numCharCountBits(version), bb);
                for (const b of seg.getData())bb.push(b);
            }
            assert(bb.length == dataUsedBits);
            const dataCapacityBits = _QrCode.getNumDataCodewords(version, ecl) * 8;
            assert(bb.length <= dataCapacityBits);
            appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);
            appendBits(0, (8 - bb.length % 8) % 8, bb);
            assert(bb.length % 8 == 0);
            for(let padByte = 236; bb.length < dataCapacityBits; padByte ^= 236 ^ 17)appendBits(padByte, 8, bb);
            let dataCodewords = [];
            while(dataCodewords.length * 8 < bb.length)dataCodewords.push(0);
            bb.forEach((b, i)=>dataCodewords[i >>> 3] |= b << 7 - (i & 7));
            return new _QrCode(version, ecl, dataCodewords, mask);
        }
        /*-- Accessor methods --*/ // Returns the color of the module (pixel) at the given coordinates, which is false
        // for light or true for dark. The top left corner has the coordinates (x=0, y=0).
        // If the given coordinates are out of bounds, then false (light) is returned.
        getModule(x, y) {
            return 0 <= x && x < this.size && 0 <= y && y < this.size && this.modules[y][x];
        }
        // Modified to expose modules for easy access
        getModules() {
            return this.modules;
        }
        /*-- Private helper methods for constructor: Drawing function modules --*/ // Reads this object's version field, and draws and marks all function modules.
        drawFunctionPatterns() {
            for(let i = 0; i < this.size; i++){
                this.setFunctionModule(6, i, i % 2 == 0);
                this.setFunctionModule(i, 6, i % 2 == 0);
            }
            this.drawFinderPattern(3, 3);
            this.drawFinderPattern(this.size - 4, 3);
            this.drawFinderPattern(3, this.size - 4);
            const alignPatPos = this.getAlignmentPatternPositions();
            const numAlign = alignPatPos.length;
            for(let i = 0; i < numAlign; i++){
                for(let j = 0; j < numAlign; j++){
                    if (!(i == 0 && j == 0 || i == 0 && j == numAlign - 1 || i == numAlign - 1 && j == 0)) this.drawAlignmentPattern(alignPatPos[i], alignPatPos[j]);
                }
            }
            this.drawFormatBits(0);
            this.drawVersion();
        }
        // Draws two copies of the format bits (with its own error correction code)
        // based on the given mask and this object's error correction level field.
        drawFormatBits(mask) {
            const data = this.errorCorrectionLevel.formatBits << 3 | mask;
            let rem = data;
            for(let i = 0; i < 10; i++)rem = rem << 1 ^ (rem >>> 9) * 1335;
            const bits = (data << 10 | rem) ^ 21522;
            assert(bits >>> 15 == 0);
            for(let i = 0; i <= 5; i++)this.setFunctionModule(8, i, getBit(bits, i));
            this.setFunctionModule(8, 7, getBit(bits, 6));
            this.setFunctionModule(8, 8, getBit(bits, 7));
            this.setFunctionModule(7, 8, getBit(bits, 8));
            for(let i = 9; i < 15; i++)this.setFunctionModule(14 - i, 8, getBit(bits, i));
            for(let i = 0; i < 8; i++)this.setFunctionModule(this.size - 1 - i, 8, getBit(bits, i));
            for(let i = 8; i < 15; i++)this.setFunctionModule(8, this.size - 15 + i, getBit(bits, i));
            this.setFunctionModule(8, this.size - 8, true);
        }
        // Draws two copies of the version bits (with its own error correction code),
        // based on this object's version field, iff 7 <= version <= 40.
        drawVersion() {
            if (this.version < 7) return;
            let rem = this.version;
            for(let i = 0; i < 12; i++)rem = rem << 1 ^ (rem >>> 11) * 7973;
            const bits = this.version << 12 | rem;
            assert(bits >>> 18 == 0);
            for(let i = 0; i < 18; i++){
                const color = getBit(bits, i);
                const a = this.size - 11 + i % 3;
                const b = Math.floor(i / 3);
                this.setFunctionModule(a, b, color);
                this.setFunctionModule(b, a, color);
            }
        }
        // Draws a 9*9 finder pattern including the border separator,
        // with the center module at (x, y). Modules can be out of bounds.
        drawFinderPattern(x, y) {
            for(let dy = -4; dy <= 4; dy++){
                for(let dx = -4; dx <= 4; dx++){
                    const dist = Math.max(Math.abs(dx), Math.abs(dy));
                    const xx = x + dx;
                    const yy = y + dy;
                    if (0 <= xx && xx < this.size && 0 <= yy && yy < this.size) this.setFunctionModule(xx, yy, dist != 2 && dist != 4);
                }
            }
        }
        // Draws a 5*5 alignment pattern, with the center module
        // at (x, y). All modules must be in bounds.
        drawAlignmentPattern(x, y) {
            for(let dy = -2; dy <= 2; dy++){
                for(let dx = -2; dx <= 2; dx++)this.setFunctionModule(x + dx, y + dy, Math.max(Math.abs(dx), Math.abs(dy)) != 1);
            }
        }
        // Sets the color of a module and marks it as a function module.
        // Only used by the constructor. Coordinates must be in bounds.
        setFunctionModule(x, y, isDark) {
            this.modules[y][x] = isDark;
            this.isFunction[y][x] = true;
        }
        /*-- Private helper methods for constructor: Codewords and masking --*/ // Returns a new byte string representing the given data with the appropriate error correction
        // codewords appended to it, based on this object's version and error correction level.
        addEccAndInterleave(data) {
            const ver = this.version;
            const ecl = this.errorCorrectionLevel;
            if (data.length != _QrCode.getNumDataCodewords(ver, ecl)) throw new RangeError("Invalid argument");
            const numBlocks = _QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
            const blockEccLen = _QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver];
            const rawCodewords = Math.floor(_QrCode.getNumRawDataModules(ver) / 8);
            const numShortBlocks = numBlocks - rawCodewords % numBlocks;
            const shortBlockLen = Math.floor(rawCodewords / numBlocks);
            let blocks = [];
            const rsDiv = _QrCode.reedSolomonComputeDivisor(blockEccLen);
            for(let i = 0, k = 0; i < numBlocks; i++){
                let dat = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));
                k += dat.length;
                const ecc = _QrCode.reedSolomonComputeRemainder(dat, rsDiv);
                if (i < numShortBlocks) dat.push(0);
                blocks.push(dat.concat(ecc));
            }
            let result = [];
            for(let i = 0; i < blocks[0].length; i++){
                blocks.forEach((block, j)=>{
                    if (i != shortBlockLen - blockEccLen || j >= numShortBlocks) result.push(block[i]);
                });
            }
            assert(result.length == rawCodewords);
            return result;
        }
        // Draws the given sequence of 8-bit codewords (data and error correction) onto the entire
        // data area of this QR Code. Function modules need to be marked off before this is called.
        drawCodewords(data) {
            if (data.length != Math.floor(_QrCode.getNumRawDataModules(this.version) / 8)) throw new RangeError("Invalid argument");
            let i = 0;
            for(let right = this.size - 1; right >= 1; right -= 2){
                if (right == 6) right = 5;
                for(let vert = 0; vert < this.size; vert++){
                    for(let j = 0; j < 2; j++){
                        const x = right - j;
                        const upward = (right + 1 & 2) == 0;
                        const y = upward ? this.size - 1 - vert : vert;
                        if (!this.isFunction[y][x] && i < data.length * 8) {
                            this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));
                            i++;
                        }
                    }
                }
            }
            assert(i == data.length * 8);
        }
        // XORs the codeword modules in this QR Code with the given mask pattern.
        // The function modules must be marked and the codeword bits must be drawn
        // before masking. Due to the arithmetic of XOR, calling applyMask() with
        // the same mask value a second time will undo the mask. A final well-formed
        // QR Code needs exactly one (not zero, two, etc.) mask applied.
        applyMask(mask) {
            if (mask < 0 || mask > 7) throw new RangeError("Mask value out of range");
            for(let y = 0; y < this.size; y++){
                for(let x = 0; x < this.size; x++){
                    let invert;
                    switch(mask){
                        case 0:
                            invert = (x + y) % 2 == 0;
                            break;
                        case 1:
                            invert = y % 2 == 0;
                            break;
                        case 2:
                            invert = x % 3 == 0;
                            break;
                        case 3:
                            invert = (x + y) % 3 == 0;
                            break;
                        case 4:
                            invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 == 0;
                            break;
                        case 5:
                            invert = x * y % 2 + x * y % 3 == 0;
                            break;
                        case 6:
                            invert = (x * y % 2 + x * y % 3) % 2 == 0;
                            break;
                        case 7:
                            invert = ((x + y) % 2 + x * y % 3) % 2 == 0;
                            break;
                        default:
                            throw new Error("Unreachable");
                    }
                    if (!this.isFunction[y][x] && invert) this.modules[y][x] = !this.modules[y][x];
                }
            }
        }
        // Calculates and returns the penalty score based on state of this QR Code's current modules.
        // This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.
        getPenaltyScore() {
            let result = 0;
            for(let y = 0; y < this.size; y++){
                let runColor = false;
                let runX = 0;
                let runHistory = [
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ];
                for(let x = 0; x < this.size; x++){
                    if (this.modules[y][x] == runColor) {
                        runX++;
                        if (runX == 5) result += _QrCode.PENALTY_N1;
                        else if (runX > 5) result++;
                    } else {
                        this.finderPenaltyAddHistory(runX, runHistory);
                        if (!runColor) result += this.finderPenaltyCountPatterns(runHistory) * _QrCode.PENALTY_N3;
                        runColor = this.modules[y][x];
                        runX = 1;
                    }
                }
                result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * _QrCode.PENALTY_N3;
            }
            for(let x = 0; x < this.size; x++){
                let runColor = false;
                let runY = 0;
                let runHistory = [
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0
                ];
                for(let y = 0; y < this.size; y++){
                    if (this.modules[y][x] == runColor) {
                        runY++;
                        if (runY == 5) result += _QrCode.PENALTY_N1;
                        else if (runY > 5) result++;
                    } else {
                        this.finderPenaltyAddHistory(runY, runHistory);
                        if (!runColor) result += this.finderPenaltyCountPatterns(runHistory) * _QrCode.PENALTY_N3;
                        runColor = this.modules[y][x];
                        runY = 1;
                    }
                }
                result += this.finderPenaltyTerminateAndCount(runColor, runY, runHistory) * _QrCode.PENALTY_N3;
            }
            for(let y = 0; y < this.size - 1; y++){
                for(let x = 0; x < this.size - 1; x++){
                    const color = this.modules[y][x];
                    if (color == this.modules[y][x + 1] && color == this.modules[y + 1][x] && color == this.modules[y + 1][x + 1]) result += _QrCode.PENALTY_N2;
                }
            }
            let dark = 0;
            for (const row of this.modules)dark = row.reduce((sum, color)=>sum + (color ? 1 : 0), dark);
            const total = this.size * this.size;
            const k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;
            assert(0 <= k && k <= 9);
            result += k * _QrCode.PENALTY_N4;
            assert(0 <= result && result <= 2568888);
            return result;
        }
        /*-- Private helper functions --*/ // Returns an ascending list of positions of alignment patterns for this version number.
        // Each position is in the range [0,177), and are used on both the x and y axes.
        // This could be implemented as lookup table of 40 variable-length lists of integers.
        getAlignmentPatternPositions() {
            if (this.version == 1) return [];
            else {
                const numAlign = Math.floor(this.version / 7) + 2;
                const step = this.version == 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;
                let result = [
                    6
                ];
                for(let pos = this.size - 7; result.length < numAlign; pos -= step)result.splice(1, 0, pos);
                return result;
            }
        }
        // Returns the number of data bits that can be stored in a QR Code of the given version number, after
        // all function modules are excluded. This includes remainder bits, so it might not be a multiple of 8.
        // The result is in the range [208, 29648]. This could be implemented as a 40-entry lookup table.
        static getNumRawDataModules(ver) {
            if (ver < _QrCode.MIN_VERSION || ver > _QrCode.MAX_VERSION) throw new RangeError("Version number out of range");
            let result = (16 * ver + 128) * ver + 64;
            if (ver >= 2) {
                const numAlign = Math.floor(ver / 7) + 2;
                result -= (25 * numAlign - 10) * numAlign - 55;
                if (ver >= 7) result -= 36;
            }
            assert(208 <= result && result <= 29648);
            return result;
        }
        // Returns the number of 8-bit data (i.e. not error correction) codewords contained in any
        // QR Code of the given version number and error correction level, with remainder bits discarded.
        // This stateless pure function could be implemented as a (40*4)-cell lookup table.
        static getNumDataCodewords(ver, ecl) {
            return Math.floor(_QrCode.getNumRawDataModules(ver) / 8) - _QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] * _QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
        }
        // Returns a Reed-Solomon ECC generator polynomial for the given degree. This could be
        // implemented as a lookup table over all possible parameter values, instead of as an algorithm.
        static reedSolomonComputeDivisor(degree) {
            if (degree < 1 || degree > 255) throw new RangeError("Degree out of range");
            let result = [];
            for(let i = 0; i < degree - 1; i++)result.push(0);
            result.push(1);
            let root = 1;
            for(let i = 0; i < degree; i++){
                for(let j = 0; j < result.length; j++){
                    result[j] = _QrCode.reedSolomonMultiply(result[j], root);
                    if (j + 1 < result.length) result[j] ^= result[j + 1];
                }
                root = _QrCode.reedSolomonMultiply(root, 2);
            }
            return result;
        }
        // Returns the Reed-Solomon error correction codeword for the given data and divisor polynomials.
        static reedSolomonComputeRemainder(data, divisor) {
            let result = divisor.map((_)=>0);
            for (const b of data){
                const factor = b ^ result.shift();
                result.push(0);
                divisor.forEach((coef, i)=>result[i] ^= _QrCode.reedSolomonMultiply(coef, factor));
            }
            return result;
        }
        // Returns the product of the two given field elements modulo GF(2^8/0x11D). The arguments and result
        // are unsigned 8-bit integers. This could be implemented as a lookup table of 256*256 entries of uint8.
        static reedSolomonMultiply(x, y) {
            if (x >>> 8 != 0 || y >>> 8 != 0) throw new RangeError("Byte out of range");
            let z = 0;
            for(let i = 7; i >= 0; i--){
                z = z << 1 ^ (z >>> 7) * 285;
                z ^= (y >>> i & 1) * x;
            }
            assert(z >>> 8 == 0);
            return z;
        }
        // Can only be called immediately after a light run is added, and
        // returns either 0, 1, or 2. A helper function for getPenaltyScore().
        finderPenaltyCountPatterns(runHistory) {
            const n = runHistory[1];
            assert(n <= this.size * 3);
            const core = n > 0 && runHistory[2] == n && runHistory[3] == n * 3 && runHistory[4] == n && runHistory[5] == n;
            return (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0) + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);
        }
        // Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().
        finderPenaltyTerminateAndCount(currentRunColor, currentRunLength, runHistory) {
            if (currentRunColor) {
                this.finderPenaltyAddHistory(currentRunLength, runHistory);
                currentRunLength = 0;
            }
            currentRunLength += this.size;
            this.finderPenaltyAddHistory(currentRunLength, runHistory);
            return this.finderPenaltyCountPatterns(runHistory);
        }
        // Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().
        finderPenaltyAddHistory(currentRunLength, runHistory) {
            if (runHistory[0] == 0) currentRunLength += this.size;
            runHistory.pop();
            runHistory.unshift(currentRunLength);
        }
    };
    /*-- Constants and tables --*/ // The minimum version number supported in the QR Code Model 2 standard.
    _QrCode.MIN_VERSION = 1;
    // The maximum version number supported in the QR Code Model 2 standard.
    _QrCode.MAX_VERSION = 40;
    // For use in getPenaltyScore(), when evaluating which mask is best.
    _QrCode.PENALTY_N1 = 3;
    _QrCode.PENALTY_N2 = 3;
    _QrCode.PENALTY_N3 = 40;
    _QrCode.PENALTY_N4 = 10;
    _QrCode.ECC_CODEWORDS_PER_BLOCK = [
        // Version: (note that index 0 is for padding, and is set to an illegal value)
        //0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
        [
            -1,
            7,
            10,
            15,
            20,
            26,
            18,
            20,
            24,
            30,
            18,
            20,
            24,
            26,
            30,
            22,
            24,
            28,
            30,
            28,
            28,
            28,
            28,
            30,
            30,
            26,
            28,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30
        ],
        // Low
        [
            -1,
            10,
            16,
            26,
            18,
            24,
            16,
            18,
            22,
            22,
            26,
            30,
            22,
            22,
            24,
            24,
            28,
            28,
            26,
            26,
            26,
            26,
            28,
            28,
            28,
            28,
            28,
            28,
            28,
            28,
            28,
            28,
            28,
            28,
            28,
            28,
            28,
            28,
            28,
            28,
            28
        ],
        // Medium
        [
            -1,
            13,
            22,
            18,
            26,
            18,
            24,
            18,
            22,
            20,
            24,
            28,
            26,
            24,
            20,
            30,
            24,
            28,
            28,
            26,
            30,
            28,
            30,
            30,
            30,
            30,
            28,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30
        ],
        // Quartile
        [
            -1,
            17,
            28,
            22,
            16,
            22,
            28,
            26,
            26,
            24,
            28,
            24,
            28,
            22,
            24,
            24,
            30,
            28,
            28,
            26,
            28,
            30,
            24,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30,
            30
        ]
    ];
    _QrCode.NUM_ERROR_CORRECTION_BLOCKS = [
        // Version: (note that index 0 is for padding, and is set to an illegal value)
        //0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
        [
            -1,
            1,
            1,
            1,
            1,
            1,
            2,
            2,
            2,
            2,
            4,
            4,
            4,
            4,
            4,
            6,
            6,
            6,
            6,
            7,
            8,
            8,
            9,
            9,
            10,
            12,
            12,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            19,
            20,
            21,
            22,
            24,
            25
        ],
        // Low
        [
            -1,
            1,
            1,
            1,
            2,
            2,
            4,
            4,
            4,
            5,
            5,
            5,
            8,
            9,
            9,
            10,
            10,
            11,
            13,
            14,
            16,
            17,
            17,
            18,
            20,
            21,
            23,
            25,
            26,
            28,
            29,
            31,
            33,
            35,
            37,
            38,
            40,
            43,
            45,
            47,
            49
        ],
        // Medium
        [
            -1,
            1,
            1,
            2,
            2,
            4,
            4,
            6,
            6,
            8,
            8,
            8,
            10,
            12,
            16,
            12,
            17,
            16,
            18,
            21,
            20,
            23,
            23,
            25,
            27,
            29,
            34,
            34,
            35,
            38,
            40,
            43,
            45,
            48,
            51,
            53,
            56,
            59,
            62,
            65,
            68
        ],
        // Quartile
        [
            -1,
            1,
            1,
            2,
            4,
            4,
            4,
            5,
            6,
            8,
            8,
            11,
            11,
            16,
            16,
            18,
            16,
            19,
            21,
            25,
            25,
            25,
            34,
            30,
            32,
            35,
            37,
            40,
            42,
            45,
            48,
            51,
            54,
            57,
            60,
            63,
            66,
            70,
            74,
            77,
            81
        ]
    ];
    let QrCode = _QrCode;
    qrcodegen2.QrCode = _QrCode;
    function appendBits(val, len, bb) {
        if (len < 0 || len > 31 || val >>> len != 0) throw new RangeError("Value out of range");
        for(let i = len - 1; i >= 0; i--)bb.push(val >>> i & 1);
    }
    function getBit(x, i) {
        return (x >>> i & 1) != 0;
    }
    function assert(cond) {
        if (!cond) throw new Error("Assertion error");
    }
    const _QrSegment = class _QrSegment {
        /*-- Constructor (low level) and fields --*/ // Creates a new QR Code segment with the given attributes and data.
        // The character count (numChars) must agree with the mode and the bit buffer length,
        // but the constraint isn't checked. The given bit buffer is cloned and stored.
        constructor(mode, numChars, bitData){
            this.mode = mode;
            this.numChars = numChars;
            this.bitData = bitData;
            if (numChars < 0) throw new RangeError("Invalid argument");
            this.bitData = bitData.slice();
        }
        /*-- Static factory functions (mid level) --*/ // Returns a segment representing the given binary data encoded in
        // byte mode. All input byte arrays are acceptable. Any text string
        // can be converted to UTF-8 bytes and encoded as a byte mode segment.
        static makeBytes(data) {
            let bb = [];
            for (const b of data)appendBits(b, 8, bb);
            return new _QrSegment(_QrSegment.Mode.BYTE, data.length, bb);
        }
        // Returns a segment representing the given string of decimal digits encoded in numeric mode.
        static makeNumeric(digits) {
            if (!_QrSegment.isNumeric(digits)) throw new RangeError("String contains non-numeric characters");
            let bb = [];
            for(let i = 0; i < digits.length;){
                const n = Math.min(digits.length - i, 3);
                appendBits(parseInt(digits.substring(i, i + n), 10), n * 3 + 1, bb);
                i += n;
            }
            return new _QrSegment(_QrSegment.Mode.NUMERIC, digits.length, bb);
        }
        // Returns a segment representing the given text string encoded in alphanumeric mode.
        // The characters allowed are: 0 to 9, A to Z (uppercase only), space,
        // dollar, percent, asterisk, plus, hyphen, period, slash, colon.
        static makeAlphanumeric(text) {
            if (!_QrSegment.isAlphanumeric(text)) throw new RangeError("String contains unencodable characters in alphanumeric mode");
            let bb = [];
            let i;
            for(i = 0; i + 2 <= text.length; i += 2){
                let temp = _QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;
                temp += _QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));
                appendBits(temp, 11, bb);
            }
            if (i < text.length) appendBits(_QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);
            return new _QrSegment(_QrSegment.Mode.ALPHANUMERIC, text.length, bb);
        }
        // Returns a new mutable list of zero or more segments to represent the given Unicode text string.
        // The result may use various segment modes and switch modes to optimize the length of the bit stream.
        static makeSegments(text) {
            if (text == "") return [];
            else if (_QrSegment.isNumeric(text)) return [
                _QrSegment.makeNumeric(text)
            ];
            else if (_QrSegment.isAlphanumeric(text)) return [
                _QrSegment.makeAlphanumeric(text)
            ];
            else return [
                _QrSegment.makeBytes(_QrSegment.toUtf8ByteArray(text))
            ];
        }
        // Returns a segment representing an Extended Channel Interpretation
        // (ECI) designator with the given assignment value.
        static makeEci(assignVal) {
            let bb = [];
            if (assignVal < 0) throw new RangeError("ECI assignment value out of range");
            else if (assignVal < 1 << 7) appendBits(assignVal, 8, bb);
            else if (assignVal < 1 << 14) {
                appendBits(2, 2, bb);
                appendBits(assignVal, 14, bb);
            } else if (assignVal < 1e6) {
                appendBits(6, 3, bb);
                appendBits(assignVal, 21, bb);
            } else throw new RangeError("ECI assignment value out of range");
            return new _QrSegment(_QrSegment.Mode.ECI, 0, bb);
        }
        // Tests whether the given string can be encoded as a segment in numeric mode.
        // A string is encodable iff each character is in the range 0 to 9.
        static isNumeric(text) {
            return _QrSegment.NUMERIC_REGEX.test(text);
        }
        // Tests whether the given string can be encoded as a segment in alphanumeric mode.
        // A string is encodable iff each character is in the following set: 0 to 9, A to Z
        // (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.
        static isAlphanumeric(text) {
            return _QrSegment.ALPHANUMERIC_REGEX.test(text);
        }
        /*-- Methods --*/ // Returns a new copy of the data bits of this segment.
        getData() {
            return this.bitData.slice();
        }
        // (Package-private) Calculates and returns the number of bits needed to encode the given segments at
        // the given version. The result is infinity if a segment has too many characters to fit its length field.
        static getTotalBits(segs, version) {
            let result = 0;
            for (const seg of segs){
                const ccbits = seg.mode.numCharCountBits(version);
                if (seg.numChars >= 1 << ccbits) return Infinity;
                result += 4 + ccbits + seg.bitData.length;
            }
            return result;
        }
        // Returns a new array of bytes representing the given string encoded in UTF-8.
        static toUtf8ByteArray(str) {
            str = encodeURI(str);
            let result = [];
            for(let i = 0; i < str.length; i++){
                if (str.charAt(i) != "%") result.push(str.charCodeAt(i));
                else {
                    result.push(parseInt(str.substring(i + 1, i + 3), 16));
                    i += 2;
                }
            }
            return result;
        }
    };
    /*-- Constants --*/ // Describes precisely all strings that are encodable in numeric mode.
    _QrSegment.NUMERIC_REGEX = /^[0-9]*$/;
    // Describes precisely all strings that are encodable in alphanumeric mode.
    _QrSegment.ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\/:-]*$/;
    // The set of all legal characters in alphanumeric mode,
    // where each character value maps to the index in the string.
    _QrSegment.ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
    let QrSegment = _QrSegment;
    qrcodegen2.QrSegment = _QrSegment;
})(qrcodegen || (qrcodegen = {}));
((qrcodegen2)=>{
    let QrCode;
    ((QrCode2)=>{
        const _Ecc = class _Ecc {
            // The QR Code can tolerate about 30% erroneous codewords
            /*-- Constructor and fields --*/ constructor(ordinal, formatBits){
                this.ordinal = ordinal;
                this.formatBits = formatBits;
            }
        };
        /*-- Constants --*/ _Ecc.LOW = new _Ecc(0, 1);
        // The QR Code can tolerate about  7% erroneous codewords
        _Ecc.MEDIUM = new _Ecc(1, 0);
        // The QR Code can tolerate about 15% erroneous codewords
        _Ecc.QUARTILE = new _Ecc(2, 3);
        // The QR Code can tolerate about 25% erroneous codewords
        _Ecc.HIGH = new _Ecc(3, 2);
        let Ecc = _Ecc;
        QrCode2.Ecc = _Ecc;
    })(QrCode = qrcodegen2.QrCode || (qrcodegen2.QrCode = {}));
})(qrcodegen || (qrcodegen = {}));
((qrcodegen2)=>{
    let QrSegment;
    ((QrSegment2)=>{
        const _Mode = class _Mode {
            /*-- Constructor and fields --*/ constructor(modeBits, numBitsCharCount){
                this.modeBits = modeBits;
                this.numBitsCharCount = numBitsCharCount;
            }
            /*-- Method --*/ // (Package-private) Returns the bit width of the character count field for a segment in
            // this mode in a QR Code at the given version number. The result is in the range [0, 16].
            numCharCountBits(ver) {
                return this.numBitsCharCount[Math.floor((ver + 7) / 17)];
            }
        };
        /*-- Constants --*/ _Mode.NUMERIC = new _Mode(1, [
            10,
            12,
            14
        ]);
        _Mode.ALPHANUMERIC = new _Mode(2, [
            9,
            11,
            13
        ]);
        _Mode.BYTE = new _Mode(4, [
            8,
            16,
            16
        ]);
        _Mode.KANJI = new _Mode(8, [
            8,
            10,
            12
        ]);
        _Mode.ECI = new _Mode(7, [
            0,
            0,
            0
        ]);
        let Mode = _Mode;
        QrSegment2.Mode = _Mode;
    })(QrSegment = qrcodegen2.QrSegment || (qrcodegen2.QrSegment = {}));
})(qrcodegen || (qrcodegen = {}));
var qrcodegen_default = qrcodegen;
// src/index.tsx
/**
 * @license qrcode.react
 * Copyright (c) Paul O'Shannessy
 * SPDX-License-Identifier: ISC
 */ var ERROR_LEVEL_MAP = {
    L: qrcodegen_default.QrCode.Ecc.LOW,
    M: qrcodegen_default.QrCode.Ecc.MEDIUM,
    Q: qrcodegen_default.QrCode.Ecc.QUARTILE,
    H: qrcodegen_default.QrCode.Ecc.HIGH
};
var DEFAULT_SIZE = 128;
var DEFAULT_LEVEL = "L";
var DEFAULT_BGCOLOR = "#FFFFFF";
var DEFAULT_FGCOLOR = "#000000";
var DEFAULT_INCLUDEMARGIN = false;
var DEFAULT_MINVERSION = 1;
var SPEC_MARGIN_SIZE = 4;
var DEFAULT_MARGIN_SIZE = 0;
var DEFAULT_IMG_SCALE = 0.1;
function generatePath(modules, margin = 0) {
    const ops = [];
    modules.forEach(function(row, y) {
        let start = null;
        row.forEach(function(cell, x) {
            if (!cell && start !== null) {
                ops.push(`M${start + margin} ${y + margin}h${x - start}v1H${start + margin}z`);
                start = null;
                return;
            }
            if (x === row.length - 1) {
                if (!cell) {
                    return;
                }
                if (start === null) {
                    ops.push(`M${x + margin},${y + margin} h1v1H${x + margin}z`);
                } else {
                    ops.push(`M${start + margin},${y + margin} h${x + 1 - start}v1H${start + margin}z`);
                }
                return;
            }
            if (cell && start === null) {
                start = x;
            }
        });
    });
    return ops.join("");
}
function excavateModules(modules, excavation) {
    return modules.slice().map((row, y)=>{
        if (y < excavation.y || y >= excavation.y + excavation.h) {
            return row;
        }
        return row.map((cell, x)=>{
            if (x < excavation.x || x >= excavation.x + excavation.w) {
                return cell;
            }
            return false;
        });
    });
}
function getImageSettings(cells, size, margin, imageSettings) {
    if (imageSettings == null) {
        return null;
    }
    const numCells = cells.length + margin * 2;
    const defaultSize = Math.floor(size * DEFAULT_IMG_SCALE);
    const scale = numCells / size;
    const w = (imageSettings.width || defaultSize) * scale;
    const h = (imageSettings.height || defaultSize) * scale;
    const x = imageSettings.x == null ? cells.length / 2 - w / 2 : imageSettings.x * scale;
    const y = imageSettings.y == null ? cells.length / 2 - h / 2 : imageSettings.y * scale;
    const opacity = imageSettings.opacity == null ? 1 : imageSettings.opacity;
    let excavation = null;
    if (imageSettings.excavate) {
        let floorX = Math.floor(x);
        let floorY = Math.floor(y);
        let ceilW = Math.ceil(w + x - floorX);
        let ceilH = Math.ceil(h + y - floorY);
        excavation = {
            x: floorX,
            y: floorY,
            w: ceilW,
            h: ceilH
        };
    }
    const crossOrigin = imageSettings.crossOrigin;
    return {
        x,
        y,
        h,
        w,
        excavation,
        opacity,
        crossOrigin
    };
}
function getMarginSize(includeMargin, marginSize) {
    if (marginSize != null) {
        return Math.max(Math.floor(marginSize), 0);
    }
    return includeMargin ? SPEC_MARGIN_SIZE : DEFAULT_MARGIN_SIZE;
}
function useQRCode({ value, level, minVersion, includeMargin, marginSize, imageSettings, size, boostLevel }) {
    let qrcode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useMemo({
        "useQRCode.useMemo[qrcode]": ()=>{
            const values = Array.isArray(value) ? value : [
                value
            ];
            const segments = values.reduce({
                "useQRCode.useMemo[qrcode].segments": (accum, v)=>{
                    accum.push(...qrcodegen_default.QrSegment.makeSegments(v));
                    return accum;
                }
            }["useQRCode.useMemo[qrcode].segments"], []);
            return qrcodegen_default.QrCode.encodeSegments(segments, ERROR_LEVEL_MAP[level], minVersion, void 0, void 0, boostLevel);
        }
    }["useQRCode.useMemo[qrcode]"], [
        value,
        level,
        minVersion,
        boostLevel
    ]);
    const { cells, margin, numCells, calculatedImageSettings } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useMemo({
        "useQRCode.useMemo": ()=>{
            let cells2 = qrcode.getModules();
            const margin2 = getMarginSize(includeMargin, marginSize);
            const numCells2 = cells2.length + margin2 * 2;
            const calculatedImageSettings2 = getImageSettings(cells2, size, margin2, imageSettings);
            return {
                cells: cells2,
                margin: margin2,
                numCells: numCells2,
                calculatedImageSettings: calculatedImageSettings2
            };
        }
    }["useQRCode.useMemo"], [
        qrcode,
        size,
        imageSettings,
        includeMargin,
        marginSize
    ]);
    return {
        qrcode,
        margin,
        cells,
        numCells,
        calculatedImageSettings
    };
}
var SUPPORTS_PATH2D = function() {
    try {
        new Path2D().addPath(new Path2D());
    } catch (e) {
        return false;
    }
    return true;
}();
var QRCodeCanvas = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].forwardRef(function QRCodeCanvas2(props, forwardedRef) {
    const _a = props, { value, size = DEFAULT_SIZE, level = DEFAULT_LEVEL, bgColor = DEFAULT_BGCOLOR, fgColor = DEFAULT_FGCOLOR, includeMargin = DEFAULT_INCLUDEMARGIN, minVersion = DEFAULT_MINVERSION, boostLevel, marginSize, imageSettings } = _a, extraProps = __objRest(_a, [
        "value",
        "size",
        "level",
        "bgColor",
        "fgColor",
        "includeMargin",
        "minVersion",
        "boostLevel",
        "marginSize",
        "imageSettings"
    ]);
    const _b = extraProps, { style } = _b, otherProps = __objRest(_b, [
        "style"
    ]);
    const imgSrc = imageSettings == null ? void 0 : imageSettings.src;
    const _canvas = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useRef(null);
    const _image = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useRef(null);
    const setCanvasRef = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useCallback({
        "QRCodeCanvas.QRCodeCanvas2.useCallback[setCanvasRef]": (node)=>{
            _canvas.current = node;
            if (typeof forwardedRef === "function") {
                forwardedRef(node);
            } else if (forwardedRef) {
                forwardedRef.current = node;
            }
        }
    }["QRCodeCanvas.QRCodeCanvas2.useCallback[setCanvasRef]"], [
        forwardedRef
    ]);
    const [isImgLoaded, setIsImageLoaded] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useState(false);
    const { margin, cells, numCells, calculatedImageSettings } = useQRCode({
        value,
        level,
        minVersion,
        boostLevel,
        includeMargin,
        marginSize,
        imageSettings,
        size
    });
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect({
        "QRCodeCanvas.QRCodeCanvas2.useEffect": ()=>{
            if (_canvas.current != null) {
                const canvas = _canvas.current;
                const ctx = canvas.getContext("2d");
                if (!ctx) {
                    return;
                }
                let cellsToDraw = cells;
                const image = _image.current;
                const haveImageToRender = calculatedImageSettings != null && image !== null && image.complete && image.naturalHeight !== 0 && image.naturalWidth !== 0;
                if (haveImageToRender) {
                    if (calculatedImageSettings.excavation != null) {
                        cellsToDraw = excavateModules(cells, calculatedImageSettings.excavation);
                    }
                }
                const pixelRatio = window.devicePixelRatio || 1;
                canvas.height = canvas.width = size * pixelRatio;
                const scale = size / numCells * pixelRatio;
                ctx.scale(scale, scale);
                ctx.fillStyle = bgColor;
                ctx.fillRect(0, 0, numCells, numCells);
                ctx.fillStyle = fgColor;
                if (SUPPORTS_PATH2D) {
                    ctx.fill(new Path2D(generatePath(cellsToDraw, margin)));
                } else {
                    cells.forEach({
                        "QRCodeCanvas.QRCodeCanvas2.useEffect": function(row, rdx) {
                            row.forEach({
                                "QRCodeCanvas.QRCodeCanvas2.useEffect": function(cell, cdx) {
                                    if (cell) {
                                        ctx.fillRect(cdx + margin, rdx + margin, 1, 1);
                                    }
                                }
                            }["QRCodeCanvas.QRCodeCanvas2.useEffect"]);
                        }
                    }["QRCodeCanvas.QRCodeCanvas2.useEffect"]);
                }
                if (calculatedImageSettings) {
                    ctx.globalAlpha = calculatedImageSettings.opacity;
                }
                if (haveImageToRender) {
                    ctx.drawImage(image, calculatedImageSettings.x + margin, calculatedImageSettings.y + margin, calculatedImageSettings.w, calculatedImageSettings.h);
                }
            }
        }
    }["QRCodeCanvas.QRCodeCanvas2.useEffect"]);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].useEffect({
        "QRCodeCanvas.QRCodeCanvas2.useEffect": ()=>{
            setIsImageLoaded(false);
        }
    }["QRCodeCanvas.QRCodeCanvas2.useEffect"], [
        imgSrc
    ]);
    const canvasStyle = __spreadValues({
        height: size,
        width: size
    }, style);
    let img = null;
    if (imgSrc != null) {
        img = /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("img", {
            src: imgSrc,
            key: imgSrc,
            style: {
                display: "none"
            },
            onLoad: ()=>{
                setIsImageLoaded(true);
            },
            ref: _image,
            crossOrigin: calculatedImageSettings == null ? void 0 : calculatedImageSettings.crossOrigin
        });
    }
    return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].Fragment, null, /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("canvas", __spreadValues({
        style: canvasStyle,
        height: size,
        width: size,
        ref: setCanvasRef,
        role: "img"
    }, otherProps)), img);
});
QRCodeCanvas.displayName = "QRCodeCanvas";
var QRCodeSVG = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].forwardRef(function QRCodeSVG2(props, forwardedRef) {
    const _a = props, { value, size = DEFAULT_SIZE, level = DEFAULT_LEVEL, bgColor = DEFAULT_BGCOLOR, fgColor = DEFAULT_FGCOLOR, includeMargin = DEFAULT_INCLUDEMARGIN, minVersion = DEFAULT_MINVERSION, boostLevel, title, marginSize, imageSettings } = _a, otherProps = __objRest(_a, [
        "value",
        "size",
        "level",
        "bgColor",
        "fgColor",
        "includeMargin",
        "minVersion",
        "boostLevel",
        "title",
        "marginSize",
        "imageSettings"
    ]);
    const { margin, cells, numCells, calculatedImageSettings } = useQRCode({
        value,
        level,
        minVersion,
        boostLevel,
        includeMargin,
        marginSize,
        imageSettings,
        size
    });
    let cellsToDraw = cells;
    let image = null;
    if (imageSettings != null && calculatedImageSettings != null) {
        if (calculatedImageSettings.excavation != null) {
            cellsToDraw = excavateModules(cells, calculatedImageSettings.excavation);
        }
        image = /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("image", {
            href: imageSettings.src,
            height: calculatedImageSettings.h,
            width: calculatedImageSettings.w,
            x: calculatedImageSettings.x + margin,
            y: calculatedImageSettings.y + margin,
            preserveAspectRatio: "none",
            opacity: calculatedImageSettings.opacity,
            crossOrigin: calculatedImageSettings.crossOrigin
        });
    }
    const fgPath = generatePath(cellsToDraw, margin);
    return /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("svg", __spreadValues({
        height: size,
        width: size,
        viewBox: `0 0 ${numCells} ${numCells}`,
        ref: forwardedRef,
        role: "img"
    }, otherProps), !!title && /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("title", null, title), /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("path", {
        fill: bgColor,
        d: `M0,0 h${numCells}v${numCells}H0z`,
        shapeRendering: "crispEdges"
    }), /* @__PURE__ */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$react$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].createElement("path", {
        fill: fgColor,
        d: fgPath,
        shapeRendering: "crispEdges"
    }), image);
});
QRCodeSVG.displayName = "QRCodeSVG";
;
}}),
"[project]/node_modules/html-to-image/es/util.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "canvasToBlob": (()=>canvasToBlob),
    "checkCanvasDimensions": (()=>checkCanvasDimensions),
    "createImage": (()=>createImage),
    "delay": (()=>delay),
    "getImageSize": (()=>getImageSize),
    "getPixelRatio": (()=>getPixelRatio),
    "getStyleProperties": (()=>getStyleProperties),
    "isInstanceOfElement": (()=>isInstanceOfElement),
    "nodeToDataURL": (()=>nodeToDataURL),
    "resolveUrl": (()=>resolveUrl),
    "svgToDataURL": (()=>svgToDataURL),
    "toArray": (()=>toArray),
    "uuid": (()=>uuid)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
function resolveUrl(url, baseUrl) {
    // url is absolute already
    if (url.match(/^[a-z]+:\/\//i)) {
        return url;
    }
    // url is absolute already, without protocol
    if (url.match(/^\/\//)) {
        return window.location.protocol + url;
    }
    // dataURI, mailto:, tel:, etc.
    if (url.match(/^[a-z]+:/i)) {
        return url;
    }
    const doc = document.implementation.createHTMLDocument();
    const base = doc.createElement('base');
    const a = doc.createElement('a');
    doc.head.appendChild(base);
    doc.body.appendChild(a);
    if (baseUrl) {
        base.href = baseUrl;
    }
    a.href = url;
    return a.href;
}
const uuid = (()=>{
    // generate uuid for className of pseudo elements.
    // We should not use GUIDs, otherwise pseudo elements sometimes cannot be captured.
    let counter = 0;
    // ref: http://stackoverflow.com/a/6248722/2519373
    const random = ()=>// eslint-disable-next-line no-bitwise
        `0000${(Math.random() * 36 ** 4 << 0).toString(36)}`.slice(-4);
    return ()=>{
        counter += 1;
        return `u${random()}${counter}`;
    };
})();
function delay(ms) {
    return (args)=>new Promise((resolve)=>{
            setTimeout(()=>resolve(args), ms);
        });
}
function toArray(arrayLike) {
    const arr = [];
    for(let i = 0, l = arrayLike.length; i < l; i++){
        arr.push(arrayLike[i]);
    }
    return arr;
}
let styleProps = null;
function getStyleProperties(options = {}) {
    if (styleProps) {
        return styleProps;
    }
    if (options.includeStyleProperties) {
        styleProps = options.includeStyleProperties;
        return styleProps;
    }
    styleProps = toArray(window.getComputedStyle(document.documentElement));
    return styleProps;
}
function px(node, styleProperty) {
    const win = node.ownerDocument.defaultView || window;
    const val = win.getComputedStyle(node).getPropertyValue(styleProperty);
    return val ? parseFloat(val.replace('px', '')) : 0;
}
function getNodeWidth(node) {
    const leftBorder = px(node, 'border-left-width');
    const rightBorder = px(node, 'border-right-width');
    return node.clientWidth + leftBorder + rightBorder;
}
function getNodeHeight(node) {
    const topBorder = px(node, 'border-top-width');
    const bottomBorder = px(node, 'border-bottom-width');
    return node.clientHeight + topBorder + bottomBorder;
}
function getImageSize(targetNode, options = {}) {
    const width = options.width || getNodeWidth(targetNode);
    const height = options.height || getNodeHeight(targetNode);
    return {
        width,
        height
    };
}
function getPixelRatio() {
    let ratio;
    let FINAL_PROCESS;
    try {
        FINAL_PROCESS = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
    } catch (e) {
    // pass
    }
    const val = FINAL_PROCESS && FINAL_PROCESS.env ? FINAL_PROCESS.env.devicePixelRatio : null;
    if (val) {
        ratio = parseInt(val, 10);
        if (Number.isNaN(ratio)) {
            ratio = 1;
        }
    }
    return ratio || window.devicePixelRatio || 1;
}
// @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas#maximum_canvas_size
const canvasDimensionLimit = 16384;
function checkCanvasDimensions(canvas) {
    if (canvas.width > canvasDimensionLimit || canvas.height > canvasDimensionLimit) {
        if (canvas.width > canvasDimensionLimit && canvas.height > canvasDimensionLimit) {
            if (canvas.width > canvas.height) {
                canvas.height *= canvasDimensionLimit / canvas.width;
                canvas.width = canvasDimensionLimit;
            } else {
                canvas.width *= canvasDimensionLimit / canvas.height;
                canvas.height = canvasDimensionLimit;
            }
        } else if (canvas.width > canvasDimensionLimit) {
            canvas.height *= canvasDimensionLimit / canvas.width;
            canvas.width = canvasDimensionLimit;
        } else {
            canvas.width *= canvasDimensionLimit / canvas.height;
            canvas.height = canvasDimensionLimit;
        }
    }
}
function canvasToBlob(canvas, options = {}) {
    if (canvas.toBlob) {
        return new Promise((resolve)=>{
            canvas.toBlob(resolve, options.type ? options.type : 'image/png', options.quality ? options.quality : 1);
        });
    }
    return new Promise((resolve)=>{
        const binaryString = window.atob(canvas.toDataURL(options.type ? options.type : undefined, options.quality ? options.quality : undefined).split(',')[1]);
        const len = binaryString.length;
        const binaryArray = new Uint8Array(len);
        for(let i = 0; i < len; i += 1){
            binaryArray[i] = binaryString.charCodeAt(i);
        }
        resolve(new Blob([
            binaryArray
        ], {
            type: options.type ? options.type : 'image/png'
        }));
    });
}
function createImage(url) {
    return new Promise((resolve, reject)=>{
        const img = new Image();
        img.onload = ()=>{
            img.decode().then(()=>{
                requestAnimationFrame(()=>resolve(img));
            });
        };
        img.onerror = reject;
        img.crossOrigin = 'anonymous';
        img.decoding = 'async';
        img.src = url;
    });
}
async function svgToDataURL(svg) {
    return Promise.resolve().then(()=>new XMLSerializer().serializeToString(svg)).then(encodeURIComponent).then((html)=>`data:image/svg+xml;charset=utf-8,${html}`);
}
async function nodeToDataURL(node, width, height) {
    const xmlns = 'http://www.w3.org/2000/svg';
    const svg = document.createElementNS(xmlns, 'svg');
    const foreignObject = document.createElementNS(xmlns, 'foreignObject');
    svg.setAttribute('width', `${width}`);
    svg.setAttribute('height', `${height}`);
    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
    foreignObject.setAttribute('width', '100%');
    foreignObject.setAttribute('height', '100%');
    foreignObject.setAttribute('x', '0');
    foreignObject.setAttribute('y', '0');
    foreignObject.setAttribute('externalResourcesRequired', 'true');
    svg.appendChild(foreignObject);
    foreignObject.appendChild(node);
    return svgToDataURL(svg);
}
const isInstanceOfElement = (node, instance)=>{
    if (node instanceof instance) return true;
    const nodePrototype = Object.getPrototypeOf(node);
    if (nodePrototype === null) return false;
    return nodePrototype.constructor.name === instance.name || isInstanceOfElement(nodePrototype, instance);
}; //# sourceMappingURL=util.js.map
}}),
"[project]/node_modules/html-to-image/es/clone-pseudos.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "clonePseudoElements": (()=>clonePseudoElements)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/html-to-image/es/util.js [app-client] (ecmascript)");
;
function formatCSSText(style) {
    const content = style.getPropertyValue('content');
    return `${style.cssText} content: '${content.replace(/'|"/g, '')}';`;
}
function formatCSSProperties(style, options) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getStyleProperties"])(options).map((name)=>{
        const value = style.getPropertyValue(name);
        const priority = style.getPropertyPriority(name);
        return `${name}: ${value}${priority ? ' !important' : ''};`;
    }).join(' ');
}
function getPseudoElementStyle(className, pseudo, style, options) {
    const selector = `.${className}:${pseudo}`;
    const cssText = style.cssText ? formatCSSText(style) : formatCSSProperties(style, options);
    return document.createTextNode(`${selector}{${cssText}}`);
}
function clonePseudoElement(nativeNode, clonedNode, pseudo, options) {
    const style = window.getComputedStyle(nativeNode, pseudo);
    const content = style.getPropertyValue('content');
    if (content === '' || content === 'none') {
        return;
    }
    const className = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uuid"])();
    try {
        clonedNode.className = `${clonedNode.className} ${className}`;
    } catch (err) {
        return;
    }
    const styleElement = document.createElement('style');
    styleElement.appendChild(getPseudoElementStyle(className, pseudo, style, options));
    clonedNode.appendChild(styleElement);
}
function clonePseudoElements(nativeNode, clonedNode, options) {
    clonePseudoElement(nativeNode, clonedNode, ':before', options);
    clonePseudoElement(nativeNode, clonedNode, ':after', options);
} //# sourceMappingURL=clone-pseudos.js.map
}}),
"[project]/node_modules/html-to-image/es/mimes.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "getMimeType": (()=>getMimeType)
});
const WOFF = 'application/font-woff';
const JPEG = 'image/jpeg';
const mimes = {
    woff: WOFF,
    woff2: WOFF,
    ttf: 'application/font-truetype',
    eot: 'application/vnd.ms-fontobject',
    png: 'image/png',
    jpg: JPEG,
    jpeg: JPEG,
    gif: 'image/gif',
    tiff: 'image/tiff',
    svg: 'image/svg+xml',
    webp: 'image/webp'
};
function getExtension(url) {
    const match = /\.([^./]*?)$/g.exec(url);
    return match ? match[1] : '';
}
function getMimeType(url) {
    const extension = getExtension(url).toLowerCase();
    return mimes[extension] || '';
} //# sourceMappingURL=mimes.js.map
}}),
"[project]/node_modules/html-to-image/es/dataurl.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "fetchAsDataURL": (()=>fetchAsDataURL),
    "isDataUrl": (()=>isDataUrl),
    "makeDataUrl": (()=>makeDataUrl),
    "resourceToDataURL": (()=>resourceToDataURL)
});
function getContentFromDataUrl(dataURL) {
    return dataURL.split(/,/)[1];
}
function isDataUrl(url) {
    return url.search(/^(data:)/) !== -1;
}
function makeDataUrl(content, mimeType) {
    return `data:${mimeType};base64,${content}`;
}
async function fetchAsDataURL(url, init, process) {
    const res = await fetch(url, init);
    if (res.status === 404) {
        throw new Error(`Resource "${res.url}" not found`);
    }
    const blob = await res.blob();
    return new Promise((resolve, reject)=>{
        const reader = new FileReader();
        reader.onerror = reject;
        reader.onloadend = ()=>{
            try {
                resolve(process({
                    res,
                    result: reader.result
                }));
            } catch (error) {
                reject(error);
            }
        };
        reader.readAsDataURL(blob);
    });
}
const cache = {};
function getCacheKey(url, contentType, includeQueryParams) {
    let key = url.replace(/\?.*/, '');
    if (includeQueryParams) {
        key = url;
    }
    // font resource
    if (/ttf|otf|eot|woff2?/i.test(key)) {
        key = key.replace(/.*\//, '');
    }
    return contentType ? `[${contentType}]${key}` : key;
}
async function resourceToDataURL(resourceUrl, contentType, options) {
    const cacheKey = getCacheKey(resourceUrl, contentType, options.includeQueryParams);
    if (cache[cacheKey] != null) {
        return cache[cacheKey];
    }
    // ref: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache
    if (options.cacheBust) {
        // eslint-disable-next-line no-param-reassign
        resourceUrl += (/\?/.test(resourceUrl) ? '&' : '?') + new Date().getTime();
    }
    let dataURL;
    try {
        const content = await fetchAsDataURL(resourceUrl, options.fetchRequestInit, ({ res, result })=>{
            if (!contentType) {
                // eslint-disable-next-line no-param-reassign
                contentType = res.headers.get('Content-Type') || '';
            }
            return getContentFromDataUrl(result);
        });
        dataURL = makeDataUrl(content, contentType);
    } catch (error) {
        dataURL = options.imagePlaceholder || '';
        let msg = `Failed to fetch resource: ${resourceUrl}`;
        if (error) {
            msg = typeof error === 'string' ? error : error.message;
        }
        if (msg) {
            console.warn(msg);
        }
    }
    cache[cacheKey] = dataURL;
    return dataURL;
} //# sourceMappingURL=dataurl.js.map
}}),
"[project]/node_modules/html-to-image/es/clone-node.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "cloneNode": (()=>cloneNode)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$clone$2d$pseudos$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/html-to-image/es/clone-pseudos.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/html-to-image/es/util.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$mimes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/html-to-image/es/mimes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$dataurl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/html-to-image/es/dataurl.js [app-client] (ecmascript)");
;
;
;
;
async function cloneCanvasElement(canvas) {
    const dataURL = canvas.toDataURL();
    if (dataURL === 'data:,') {
        return canvas.cloneNode(false);
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createImage"])(dataURL);
}
async function cloneVideoElement(video, options) {
    if (video.currentSrc) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = video.clientWidth;
        canvas.height = video.clientHeight;
        ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        const dataURL = canvas.toDataURL();
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createImage"])(dataURL);
    }
    const poster = video.poster;
    const contentType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$mimes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getMimeType"])(poster);
    const dataURL = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$dataurl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resourceToDataURL"])(poster, contentType, options);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createImage"])(dataURL);
}
async function cloneIFrameElement(iframe, options) {
    var _a;
    try {
        if ((_a = iframe === null || iframe === void 0 ? void 0 : iframe.contentDocument) === null || _a === void 0 ? void 0 : _a.body) {
            return await cloneNode(iframe.contentDocument.body, options, true);
        }
    } catch (_b) {
    // Failed to clone iframe
    }
    return iframe.cloneNode(false);
}
async function cloneSingleNode(node, options) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInstanceOfElement"])(node, HTMLCanvasElement)) {
        return cloneCanvasElement(node);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInstanceOfElement"])(node, HTMLVideoElement)) {
        return cloneVideoElement(node, options);
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInstanceOfElement"])(node, HTMLIFrameElement)) {
        return cloneIFrameElement(node, options);
    }
    return node.cloneNode(isSVGElement(node));
}
const isSlotElement = (node)=>node.tagName != null && node.tagName.toUpperCase() === 'SLOT';
const isSVGElement = (node)=>node.tagName != null && node.tagName.toUpperCase() === 'SVG';
async function cloneChildren(nativeNode, clonedNode, options) {
    var _a, _b;
    if (isSVGElement(clonedNode)) {
        return clonedNode;
    }
    let children = [];
    if (isSlotElement(nativeNode) && nativeNode.assignedNodes) {
        children = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toArray"])(nativeNode.assignedNodes());
    } else if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInstanceOfElement"])(nativeNode, HTMLIFrameElement) && ((_a = nativeNode.contentDocument) === null || _a === void 0 ? void 0 : _a.body)) {
        children = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toArray"])(nativeNode.contentDocument.body.childNodes);
    } else {
        children = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toArray"])(((_b = nativeNode.shadowRoot) !== null && _b !== void 0 ? _b : nativeNode).childNodes);
    }
    if (children.length === 0 || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInstanceOfElement"])(nativeNode, HTMLVideoElement)) {
        return clonedNode;
    }
    await children.reduce((deferred, child)=>deferred.then(()=>cloneNode(child, options)).then((clonedChild)=>{
            if (clonedChild) {
                clonedNode.appendChild(clonedChild);
            }
        }), Promise.resolve());
    return clonedNode;
}
function cloneCSSStyle(nativeNode, clonedNode, options) {
    const targetStyle = clonedNode.style;
    if (!targetStyle) {
        return;
    }
    const sourceStyle = window.getComputedStyle(nativeNode);
    if (sourceStyle.cssText) {
        targetStyle.cssText = sourceStyle.cssText;
        targetStyle.transformOrigin = sourceStyle.transformOrigin;
    } else {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getStyleProperties"])(options).forEach((name)=>{
            let value = sourceStyle.getPropertyValue(name);
            if (name === 'font-size' && value.endsWith('px')) {
                const reducedFont = Math.floor(parseFloat(value.substring(0, value.length - 2))) - 0.1;
                value = `${reducedFont}px`;
            }
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInstanceOfElement"])(nativeNode, HTMLIFrameElement) && name === 'display' && value === 'inline') {
                value = 'block';
            }
            if (name === 'd' && clonedNode.getAttribute('d')) {
                value = `path(${clonedNode.getAttribute('d')})`;
            }
            targetStyle.setProperty(name, value, sourceStyle.getPropertyPriority(name));
        });
    }
}
function cloneInputValue(nativeNode, clonedNode) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInstanceOfElement"])(nativeNode, HTMLTextAreaElement)) {
        clonedNode.innerHTML = nativeNode.value;
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInstanceOfElement"])(nativeNode, HTMLInputElement)) {
        clonedNode.setAttribute('value', nativeNode.value);
    }
}
function cloneSelectValue(nativeNode, clonedNode) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInstanceOfElement"])(nativeNode, HTMLSelectElement)) {
        const clonedSelect = clonedNode;
        const selectedOption = Array.from(clonedSelect.children).find((child)=>nativeNode.value === child.getAttribute('value'));
        if (selectedOption) {
            selectedOption.setAttribute('selected', '');
        }
    }
}
function decorate(nativeNode, clonedNode, options) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInstanceOfElement"])(clonedNode, Element)) {
        cloneCSSStyle(nativeNode, clonedNode, options);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$clone$2d$pseudos$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clonePseudoElements"])(nativeNode, clonedNode, options);
        cloneInputValue(nativeNode, clonedNode);
        cloneSelectValue(nativeNode, clonedNode);
    }
    return clonedNode;
}
async function ensureSVGSymbols(clone, options) {
    const uses = clone.querySelectorAll ? clone.querySelectorAll('use') : [];
    if (uses.length === 0) {
        return clone;
    }
    const processedDefs = {};
    for(let i = 0; i < uses.length; i++){
        const use = uses[i];
        const id = use.getAttribute('xlink:href');
        if (id) {
            const exist = clone.querySelector(id);
            const definition = document.querySelector(id);
            if (!exist && definition && !processedDefs[id]) {
                // eslint-disable-next-line no-await-in-loop
                processedDefs[id] = await cloneNode(definition, options, true);
            }
        }
    }
    const nodes = Object.values(processedDefs);
    if (nodes.length) {
        const ns = 'http://www.w3.org/1999/xhtml';
        const svg = document.createElementNS(ns, 'svg');
        svg.setAttribute('xmlns', ns);
        svg.style.position = 'absolute';
        svg.style.width = '0';
        svg.style.height = '0';
        svg.style.overflow = 'hidden';
        svg.style.display = 'none';
        const defs = document.createElementNS(ns, 'defs');
        svg.appendChild(defs);
        for(let i = 0; i < nodes.length; i++){
            defs.appendChild(nodes[i]);
        }
        clone.appendChild(svg);
    }
    return clone;
}
async function cloneNode(node, options, isRoot) {
    if (!isRoot && options.filter && !options.filter(node)) {
        return null;
    }
    return Promise.resolve(node).then((clonedNode)=>cloneSingleNode(clonedNode, options)).then((clonedNode)=>cloneChildren(node, clonedNode, options)).then((clonedNode)=>decorate(node, clonedNode, options)).then((clonedNode)=>ensureSVGSymbols(clonedNode, options));
} //# sourceMappingURL=clone-node.js.map
}}),
"[project]/node_modules/html-to-image/es/embed-resources.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "embed": (()=>embed),
    "embedResources": (()=>embedResources),
    "parseURLs": (()=>parseURLs),
    "shouldEmbed": (()=>shouldEmbed)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/html-to-image/es/util.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$mimes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/html-to-image/es/mimes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$dataurl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/html-to-image/es/dataurl.js [app-client] (ecmascript)");
;
;
;
const URL_REGEX = /url\((['"]?)([^'"]+?)\1\)/g;
const URL_WITH_FORMAT_REGEX = /url\([^)]+\)\s*format\((["']?)([^"']+)\1\)/g;
const FONT_SRC_REGEX = /src:\s*(?:url\([^)]+\)\s*format\([^)]+\)[,;]\s*)+/g;
function toRegex(url) {
    // eslint-disable-next-line no-useless-escape
    const escaped = url.replace(/([.*+?^${}()|\[\]\/\\])/g, '\\$1');
    return new RegExp(`(url\\(['"]?)(${escaped})(['"]?\\))`, 'g');
}
function parseURLs(cssText) {
    const urls = [];
    cssText.replace(URL_REGEX, (raw, quotation, url)=>{
        urls.push(url);
        return raw;
    });
    return urls.filter((url)=>!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$dataurl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDataUrl"])(url));
}
async function embed(cssText, resourceURL, baseURL, options, getContentFromUrl) {
    try {
        const resolvedURL = baseURL ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resolveUrl"])(resourceURL, baseURL) : resourceURL;
        const contentType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$mimes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getMimeType"])(resourceURL);
        let dataURL;
        if (getContentFromUrl) {
            const content = await getContentFromUrl(resolvedURL);
            dataURL = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$dataurl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["makeDataUrl"])(content, contentType);
        } else {
            dataURL = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$dataurl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resourceToDataURL"])(resolvedURL, contentType, options);
        }
        return cssText.replace(toRegex(resourceURL), `$1${dataURL}$3`);
    } catch (error) {
    // pass
    }
    return cssText;
}
function filterPreferredFontFormat(str, { preferredFontFormat }) {
    return !preferredFontFormat ? str : str.replace(FONT_SRC_REGEX, (match)=>{
        // eslint-disable-next-line no-constant-condition
        while(true){
            const [src, , format] = URL_WITH_FORMAT_REGEX.exec(match) || [];
            if (!format) {
                return '';
            }
            if (format === preferredFontFormat) {
                return `src: ${src};`;
            }
        }
    });
}
function shouldEmbed(url) {
    return url.search(URL_REGEX) !== -1;
}
async function embedResources(cssText, baseUrl, options) {
    if (!shouldEmbed(cssText)) {
        return cssText;
    }
    const filteredCSSText = filterPreferredFontFormat(cssText, options);
    const urls = parseURLs(filteredCSSText);
    return urls.reduce((deferred, url)=>deferred.then((css)=>embed(css, url, baseUrl, options)), Promise.resolve(filteredCSSText));
} //# sourceMappingURL=embed-resources.js.map
}}),
"[project]/node_modules/html-to-image/es/embed-images.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "embedImages": (()=>embedImages)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$embed$2d$resources$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/html-to-image/es/embed-resources.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/html-to-image/es/util.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$dataurl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/html-to-image/es/dataurl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$mimes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/html-to-image/es/mimes.js [app-client] (ecmascript)");
;
;
;
;
async function embedProp(propName, node, options) {
    var _a;
    const propValue = (_a = node.style) === null || _a === void 0 ? void 0 : _a.getPropertyValue(propName);
    if (propValue) {
        const cssString = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$embed$2d$resources$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["embedResources"])(propValue, null, options);
        node.style.setProperty(propName, cssString, node.style.getPropertyPriority(propName));
        return true;
    }
    return false;
}
async function embedBackground(clonedNode, options) {
    ;
    await embedProp('background', clonedNode, options) || await embedProp('background-image', clonedNode, options);
    await embedProp('mask', clonedNode, options) || await embedProp('-webkit-mask', clonedNode, options) || await embedProp('mask-image', clonedNode, options) || await embedProp('-webkit-mask-image', clonedNode, options);
}
async function embedImageNode(clonedNode, options) {
    const isImageElement = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInstanceOfElement"])(clonedNode, HTMLImageElement);
    if (!(isImageElement && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$dataurl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDataUrl"])(clonedNode.src)) && !((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInstanceOfElement"])(clonedNode, SVGImageElement) && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$dataurl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDataUrl"])(clonedNode.href.baseVal))) {
        return;
    }
    const url = isImageElement ? clonedNode.src : clonedNode.href.baseVal;
    const dataURL = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$dataurl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["resourceToDataURL"])(url, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$mimes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getMimeType"])(url), options);
    await new Promise((resolve, reject)=>{
        clonedNode.onload = resolve;
        clonedNode.onerror = options.onImageErrorHandler ? (...attributes)=>{
            try {
                resolve(options.onImageErrorHandler(...attributes));
            } catch (error) {
                reject(error);
            }
        } : reject;
        const image = clonedNode;
        if (image.decode) {
            image.decode = resolve;
        }
        if (image.loading === 'lazy') {
            image.loading = 'eager';
        }
        if (isImageElement) {
            clonedNode.srcset = '';
            clonedNode.src = dataURL;
        } else {
            clonedNode.href.baseVal = dataURL;
        }
    });
}
async function embedChildren(clonedNode, options) {
    const children = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toArray"])(clonedNode.childNodes);
    const deferreds = children.map((child)=>embedImages(child, options));
    await Promise.all(deferreds).then(()=>clonedNode);
}
async function embedImages(clonedNode, options) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isInstanceOfElement"])(clonedNode, Element)) {
        await embedBackground(clonedNode, options);
        await embedImageNode(clonedNode, options);
        await embedChildren(clonedNode, options);
    }
} //# sourceMappingURL=embed-images.js.map
}}),
"[project]/node_modules/html-to-image/es/apply-style.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "applyStyle": (()=>applyStyle)
});
function applyStyle(node, options) {
    const { style } = node;
    if (options.backgroundColor) {
        style.backgroundColor = options.backgroundColor;
    }
    if (options.width) {
        style.width = `${options.width}px`;
    }
    if (options.height) {
        style.height = `${options.height}px`;
    }
    const manual = options.style;
    if (manual != null) {
        Object.keys(manual).forEach((key)=>{
            style[key] = manual[key];
        });
    }
    return node;
} //# sourceMappingURL=apply-style.js.map
}}),
"[project]/node_modules/html-to-image/es/embed-webfonts.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "embedWebFonts": (()=>embedWebFonts),
    "getWebFontCSS": (()=>getWebFontCSS)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/html-to-image/es/util.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$dataurl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/html-to-image/es/dataurl.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$embed$2d$resources$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/html-to-image/es/embed-resources.js [app-client] (ecmascript)");
;
;
;
const cssFetchCache = {};
async function fetchCSS(url) {
    let cache = cssFetchCache[url];
    if (cache != null) {
        return cache;
    }
    const res = await fetch(url);
    const cssText = await res.text();
    cache = {
        url,
        cssText
    };
    cssFetchCache[url] = cache;
    return cache;
}
async function embedFonts(data, options) {
    let cssText = data.cssText;
    const regexUrl = /url\(["']?([^"')]+)["']?\)/g;
    const fontLocs = cssText.match(/url\([^)]+\)/g) || [];
    const loadFonts = fontLocs.map(async (loc)=>{
        let url = loc.replace(regexUrl, '$1');
        if (!url.startsWith('https://')) {
            url = new URL(url, data.url).href;
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$dataurl$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fetchAsDataURL"])(url, options.fetchRequestInit, ({ result })=>{
            cssText = cssText.replace(loc, `url(${result})`);
            return [
                loc,
                result
            ];
        });
    });
    return Promise.all(loadFonts).then(()=>cssText);
}
function parseCSS(source) {
    if (source == null) {
        return [];
    }
    const result = [];
    const commentsRegex = /(\/\*[\s\S]*?\*\/)/gi;
    // strip out comments
    let cssText = source.replace(commentsRegex, '');
    // eslint-disable-next-line prefer-regex-literals
    const keyframesRegex = new RegExp('((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})', 'gi');
    // eslint-disable-next-line no-constant-condition
    while(true){
        const matches = keyframesRegex.exec(cssText);
        if (matches === null) {
            break;
        }
        result.push(matches[0]);
    }
    cssText = cssText.replace(keyframesRegex, '');
    const importRegex = /@import[\s\S]*?url\([^)]*\)[\s\S]*?;/gi;
    // to match css & media queries together
    const combinedCSSRegex = '((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]' + '*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})';
    // unified regex
    const unifiedRegex = new RegExp(combinedCSSRegex, 'gi');
    // eslint-disable-next-line no-constant-condition
    while(true){
        let matches = importRegex.exec(cssText);
        if (matches === null) {
            matches = unifiedRegex.exec(cssText);
            if (matches === null) {
                break;
            } else {
                importRegex.lastIndex = unifiedRegex.lastIndex;
            }
        } else {
            unifiedRegex.lastIndex = importRegex.lastIndex;
        }
        result.push(matches[0]);
    }
    return result;
}
async function getCSSRules(styleSheets, options) {
    const ret = [];
    const deferreds = [];
    // First loop inlines imports
    styleSheets.forEach((sheet)=>{
        if ('cssRules' in sheet) {
            try {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toArray"])(sheet.cssRules || []).forEach((item, index)=>{
                    if (item.type === CSSRule.IMPORT_RULE) {
                        let importIndex = index + 1;
                        const url = item.href;
                        const deferred = fetchCSS(url).then((metadata)=>embedFonts(metadata, options)).then((cssText)=>parseCSS(cssText).forEach((rule)=>{
                                try {
                                    sheet.insertRule(rule, rule.startsWith('@import') ? importIndex += 1 : sheet.cssRules.length);
                                } catch (error) {
                                    console.error('Error inserting rule from remote css', {
                                        rule,
                                        error
                                    });
                                }
                            })).catch((e)=>{
                            console.error('Error loading remote css', e.toString());
                        });
                        deferreds.push(deferred);
                    }
                });
            } catch (e) {
                const inline = styleSheets.find((a)=>a.href == null) || document.styleSheets[0];
                if (sheet.href != null) {
                    deferreds.push(fetchCSS(sheet.href).then((metadata)=>embedFonts(metadata, options)).then((cssText)=>parseCSS(cssText).forEach((rule)=>{
                            inline.insertRule(rule, inline.cssRules.length);
                        })).catch((err)=>{
                        console.error('Error loading remote stylesheet', err);
                    }));
                }
                console.error('Error inlining remote css file', e);
            }
        }
    });
    return Promise.all(deferreds).then(()=>{
        // Second loop parses rules
        styleSheets.forEach((sheet)=>{
            if ('cssRules' in sheet) {
                try {
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toArray"])(sheet.cssRules || []).forEach((item)=>{
                        ret.push(item);
                    });
                } catch (e) {
                    console.error(`Error while reading CSS rules from ${sheet.href}`, e);
                }
            }
        });
        return ret;
    });
}
function getWebFontRules(cssRules) {
    return cssRules.filter((rule)=>rule.type === CSSRule.FONT_FACE_RULE).filter((rule)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$embed$2d$resources$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shouldEmbed"])(rule.style.getPropertyValue('src')));
}
async function parseWebFontRules(node, options) {
    if (node.ownerDocument == null) {
        throw new Error('Provided element is not within a Document');
    }
    const styleSheets = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toArray"])(node.ownerDocument.styleSheets);
    const cssRules = await getCSSRules(styleSheets, options);
    return getWebFontRules(cssRules);
}
function normalizeFontFamily(font) {
    return font.trim().replace(/["']/g, '');
}
function getUsedFonts(node) {
    const fonts = new Set();
    function traverse(node) {
        const fontFamily = node.style.fontFamily || getComputedStyle(node).fontFamily;
        fontFamily.split(',').forEach((font)=>{
            fonts.add(normalizeFontFamily(font));
        });
        Array.from(node.children).forEach((child)=>{
            if (child instanceof HTMLElement) {
                traverse(child);
            }
        });
    }
    traverse(node);
    return fonts;
}
async function getWebFontCSS(node, options) {
    const rules = await parseWebFontRules(node, options);
    const usedFonts = getUsedFonts(node);
    const cssTexts = await Promise.all(rules.filter((rule)=>usedFonts.has(normalizeFontFamily(rule.style.fontFamily))).map((rule)=>{
        const baseUrl = rule.parentStyleSheet ? rule.parentStyleSheet.href : null;
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$embed$2d$resources$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["embedResources"])(rule.cssText, baseUrl, options);
    }));
    return cssTexts.join('\n');
}
async function embedWebFonts(clonedNode, options) {
    const cssText = options.fontEmbedCSS != null ? options.fontEmbedCSS : options.skipFonts ? null : await getWebFontCSS(clonedNode, options);
    if (cssText) {
        const styleNode = document.createElement('style');
        const sytleContent = document.createTextNode(cssText);
        styleNode.appendChild(sytleContent);
        if (clonedNode.firstChild) {
            clonedNode.insertBefore(styleNode, clonedNode.firstChild);
        } else {
            clonedNode.appendChild(styleNode);
        }
    }
} //# sourceMappingURL=embed-webfonts.js.map
}}),
"[project]/node_modules/html-to-image/es/index.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "getFontEmbedCSS": (()=>getFontEmbedCSS),
    "toBlob": (()=>toBlob),
    "toCanvas": (()=>toCanvas),
    "toJpeg": (()=>toJpeg),
    "toPixelData": (()=>toPixelData),
    "toPng": (()=>toPng),
    "toSvg": (()=>toSvg)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$clone$2d$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/html-to-image/es/clone-node.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$embed$2d$images$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/html-to-image/es/embed-images.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$apply$2d$style$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/html-to-image/es/apply-style.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$embed$2d$webfonts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/html-to-image/es/embed-webfonts.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/html-to-image/es/util.js [app-client] (ecmascript)");
;
;
;
;
;
async function toSvg(node, options = {}) {
    const { width, height } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getImageSize"])(node, options);
    const clonedNode = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$clone$2d$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["cloneNode"])(node, options, true);
    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$embed$2d$webfonts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["embedWebFonts"])(clonedNode, options);
    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$embed$2d$images$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["embedImages"])(clonedNode, options);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$apply$2d$style$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["applyStyle"])(clonedNode, options);
    const datauri = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["nodeToDataURL"])(clonedNode, width, height);
    return datauri;
}
async function toCanvas(node, options = {}) {
    const { width, height } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getImageSize"])(node, options);
    const svg = await toSvg(node, options);
    const img = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createImage"])(svg);
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');
    const ratio = options.pixelRatio || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPixelRatio"])();
    const canvasWidth = options.canvasWidth || width;
    const canvasHeight = options.canvasHeight || height;
    canvas.width = canvasWidth * ratio;
    canvas.height = canvasHeight * ratio;
    if (!options.skipAutoScale) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["checkCanvasDimensions"])(canvas);
    }
    canvas.style.width = `${canvasWidth}`;
    canvas.style.height = `${canvasHeight}`;
    if (options.backgroundColor) {
        context.fillStyle = options.backgroundColor;
        context.fillRect(0, 0, canvas.width, canvas.height);
    }
    context.drawImage(img, 0, 0, canvas.width, canvas.height);
    return canvas;
}
async function toPixelData(node, options = {}) {
    const { width, height } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getImageSize"])(node, options);
    const canvas = await toCanvas(node, options);
    const ctx = canvas.getContext('2d');
    return ctx.getImageData(0, 0, width, height).data;
}
async function toPng(node, options = {}) {
    const canvas = await toCanvas(node, options);
    return canvas.toDataURL();
}
async function toJpeg(node, options = {}) {
    const canvas = await toCanvas(node, options);
    return canvas.toDataURL('image/jpeg', options.quality || 1);
}
async function toBlob(node, options = {}) {
    const canvas = await toCanvas(node, options);
    const blob = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["canvasToBlob"])(canvas);
    return blob;
}
async function getFontEmbedCSS(node, options = {}) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$html$2d$to$2d$image$2f$es$2f$embed$2d$webfonts$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getWebFontCSS"])(node, options);
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/gifshot/dist/gifshot.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*Copyrights for code authored by Yahoo Inc. is licensed under the following terms:
MIT License
Copyright  2017 Yahoo Inc.
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/ ;
(function(window1, document1, navigator, undefined) {
    "use strict";
    /*
  utils.js
  ========
*/ /* Copyright  2017 Yahoo Inc.
 * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.
*/ var utils = {
        URL: window1.URL || window1.webkitURL || window1.mozURL || window1.msURL,
        getUserMedia: function() {
            var getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
            return getUserMedia ? getUserMedia.bind(navigator) : getUserMedia;
        }(),
        requestAnimFrame: window1.requestAnimationFrame || window1.webkitRequestAnimationFrame || window1.mozRequestAnimationFrame || window1.oRequestAnimationFrame || window1.msRequestAnimationFrame,
        requestTimeout: function requestTimeout(callback, delay) {
            callback = callback || utils.noop;
            delay = delay || 0;
            if (!utils.requestAnimFrame) {
                return setTimeout(callback, delay);
            }
            var start = new Date().getTime();
            var handle = new Object();
            var requestAnimFrame = utils.requestAnimFrame;
            var loop = function loop() {
                var current = new Date().getTime();
                var delta = current - start;
                delta >= delay ? callback.call() : handle.value = requestAnimFrame(loop);
            };
            handle.value = requestAnimFrame(loop);
            return handle;
        },
        Blob: window1.Blob || window1.BlobBuilder || window1.WebKitBlobBuilder || window1.MozBlobBuilder || window1.MSBlobBuilder,
        btoa: function() {
            var btoa = window1.btoa || function(input) {
                var output = '';
                var i = 0;
                var l = input.length;
                var key = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
                var chr1 = void 0;
                var chr2 = void 0;
                var chr3 = void 0;
                var enc1 = void 0;
                var enc2 = void 0;
                var enc3 = void 0;
                var enc4 = void 0;
                while(i < l){
                    chr1 = input.charCodeAt(i++);
                    chr2 = input.charCodeAt(i++);
                    chr3 = input.charCodeAt(i++);
                    enc1 = chr1 >> 2;
                    enc2 = (chr1 & 3) << 4 | chr2 >> 4;
                    enc3 = (chr2 & 15) << 2 | chr3 >> 6;
                    enc4 = chr3 & 63;
                    if (isNaN(chr2)) {
                        enc3 = enc4 = 64;
                    } else if (isNaN(chr3)) {
                        enc4 = 64;
                    }
                    output = output + key.charAt(enc1) + key.charAt(enc2) + key.charAt(enc3) + key.charAt(enc4);
                }
                return output;
            };
            return ("TURBOPACK compile-time truthy", 1) ? btoa.bind(window1) : ("TURBOPACK unreachable", undefined);
        }(),
        isObject: function isObject(obj) {
            return obj && Object.prototype.toString.call(obj) === '[object Object]';
        },
        isEmptyObject: function isEmptyObject(obj) {
            return utils.isObject(obj) && !Object.keys(obj).length;
        },
        isArray: function isArray(arr) {
            return arr && Array.isArray(arr);
        },
        isFunction: function isFunction(func) {
            return func && typeof func === 'function';
        },
        isElement: function isElement(elem) {
            return elem && elem.nodeType === 1;
        },
        isString: function isString(value) {
            return typeof value === 'string' || Object.prototype.toString.call(value) === '[object String]';
        },
        isSupported: {
            canvas: function canvas() {
                var el = document1.createElement('canvas');
                return el && el.getContext && el.getContext('2d');
            },
            webworkers: function webworkers() {
                return window1.Worker;
            },
            blob: function blob() {
                return utils.Blob;
            },
            Uint8Array: function Uint8Array1() {
                return window1.Uint8Array;
            },
            Uint32Array: function Uint32Array1() {
                return window1.Uint32Array;
            },
            videoCodecs: function() {
                var testEl = document1.createElement('video');
                var supportObj = {
                    'mp4': false,
                    'h264': false,
                    'ogv': false,
                    'ogg': false,
                    'webm': false
                };
                try {
                    if (testEl && testEl.canPlayType) {
                        // Check for MPEG-4 support
                        supportObj.mp4 = testEl.canPlayType('video/mp4; codecs="mp4v.20.8"') !== '';
                        // Check for h264 support
                        supportObj.h264 = (testEl.canPlayType('video/mp4; codecs="avc1.42E01E"') || testEl.canPlayType('video/mp4; codecs="avc1.42E01E, mp4a.40.2"')) !== '';
                        // Check for Ogv support
                        supportObj.ogv = testEl.canPlayType('video/ogg; codecs="theora"') !== '';
                        // Check for Ogg support
                        supportObj.ogg = testEl.canPlayType('video/ogg; codecs="theora"') !== '';
                        // Check for Webm support
                        supportObj.webm = testEl.canPlayType('video/webm; codecs="vp8, vorbis"') !== -1;
                    }
                } catch (e) {}
                return supportObj;
            }()
        },
        noop: function noop() {},
        each: function each(collection, callback) {
            var x = void 0;
            var len = void 0;
            if (utils.isArray(collection)) {
                x = -1;
                len = collection.length;
                while(++x < len){
                    if (callback(x, collection[x]) === false) {
                        break;
                    }
                }
            } else if (utils.isObject(collection)) {
                for(x in collection){
                    if (collection.hasOwnProperty(x)) {
                        if (callback(x, collection[x]) === false) {
                            break;
                        }
                    }
                }
            }
        },
        mergeOptions: function mergeOptions(defaultOptions, userOptions) {
            if (!utils.isObject(defaultOptions) || !utils.isObject(userOptions) || !Object.keys) {
                return;
            }
            var newObj = {};
            utils.each(defaultOptions, function(key, val) {
                newObj[key] = defaultOptions[key];
            });
            utils.each(userOptions, function(key, val) {
                var currentUserOption = userOptions[key];
                if (!utils.isObject(currentUserOption)) {
                    newObj[key] = currentUserOption;
                } else {
                    if (!defaultOptions[key]) {
                        newObj[key] = currentUserOption;
                    } else {
                        newObj[key] = utils.mergeOptions(defaultOptions[key], currentUserOption);
                    }
                }
            });
            return newObj;
        },
        setCSSAttr: function setCSSAttr(elem, attr, val) {
            if (!utils.isElement(elem)) {
                return;
            }
            if (utils.isString(attr) && utils.isString(val)) {
                elem.style[attr] = val;
            } else if (utils.isObject(attr)) {
                utils.each(attr, function(key, val) {
                    elem.style[key] = val;
                });
            }
        },
        removeElement: function removeElement(node) {
            if (!utils.isElement(node)) {
                return;
            }
            if (node.parentNode) {
                node.parentNode.removeChild(node);
            }
        },
        createWebWorker: function createWebWorker(content) {
            if (!utils.isString(content)) {
                return {};
            }
            try {
                var blob = new utils.Blob([
                    content
                ], {
                    'type': 'text/javascript'
                });
                var objectUrl = utils.URL.createObjectURL(blob);
                var worker = new Worker(objectUrl);
                return {
                    'objectUrl': objectUrl,
                    'worker': worker
                };
            } catch (e) {
                return '' + e;
            }
        },
        getExtension: function getExtension(src) {
            return src.substr(src.lastIndexOf('.') + 1, src.length);
        },
        getFontSize: function getFontSize() {
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            if (!document1.body || options.resizeFont === false) {
                return options.fontSize;
            }
            var text = options.text;
            var containerWidth = options.gifWidth;
            var fontSize = parseInt(options.fontSize, 10);
            var minFontSize = parseInt(options.minFontSize, 10);
            var div = document1.createElement('div');
            var span = document1.createElement('span');
            div.setAttribute('width', containerWidth);
            div.appendChild(span);
            span.innerHTML = text;
            span.style.fontSize = fontSize + 'px';
            span.style.textIndent = '-9999px';
            span.style.visibility = 'hidden';
            document1.body.appendChild(span);
            while(span.offsetWidth > containerWidth && fontSize >= minFontSize){
                span.style.fontSize = --fontSize + 'px';
            }
            document1.body.removeChild(span);
            return fontSize + 'px';
        },
        webWorkerError: false
    };
    var utils$2 = Object.freeze({
        default: utils
    });
    /*
  error.js
  ========
*/ /* Copyright  2017 Yahoo Inc.
 * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.
*/ // Dependencies
    var error = {
        validate: function validate(skipObj) {
            skipObj = utils.isObject(skipObj) ? skipObj : {};
            var errorObj = {};
            utils.each(error.validators, function(indece, currentValidator) {
                var errorCode = currentValidator.errorCode;
                if (!skipObj[errorCode] && !currentValidator.condition) {
                    errorObj = currentValidator;
                    errorObj.error = true;
                    return false;
                }
            });
            delete errorObj.condition;
            return errorObj;
        },
        isValid: function isValid(skipObj) {
            var errorObj = error.validate(skipObj);
            var isValid = errorObj.error !== true ? true : false;
            return isValid;
        },
        validators: [
            {
                condition: utils.isFunction(utils.getUserMedia),
                errorCode: 'getUserMedia',
                errorMsg: 'The getUserMedia API is not supported in your browser'
            },
            {
                condition: utils.isSupported.canvas(),
                errorCode: 'canvas',
                errorMsg: 'Canvas elements are not supported in your browser'
            },
            {
                condition: utils.isSupported.webworkers(),
                errorCode: 'webworkers',
                errorMsg: 'The Web Workers API is not supported in your browser'
            },
            {
                condition: utils.isFunction(utils.URL),
                errorCode: 'window.URL',
                errorMsg: 'The window.URL API is not supported in your browser'
            },
            {
                condition: utils.isSupported.blob(),
                errorCode: 'window.Blob',
                errorMsg: 'The window.Blob File API is not supported in your browser'
            },
            {
                condition: utils.isSupported.Uint8Array(),
                errorCode: 'window.Uint8Array',
                errorMsg: 'The window.Uint8Array function constructor is not supported in your browser'
            },
            {
                condition: utils.isSupported.Uint32Array(),
                errorCode: 'window.Uint32Array',
                errorMsg: 'The window.Uint32Array function constructor is not supported in your browser'
            }
        ],
        messages: {
            videoCodecs: {
                errorCode: 'videocodec',
                errorMsg: 'The video codec you are trying to use is not supported in your browser'
            }
        }
    };
    var error$2 = Object.freeze({
        default: error
    });
    /*
  defaultOptions.js
  =================
*/ /* Copyright  2017 Yahoo Inc.
 * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.
*/ // Helpers
    var noop = function noop() {};
    var defaultOptions = {
        sampleInterval: 10,
        numWorkers: 2,
        filter: '',
        gifWidth: 200,
        gifHeight: 200,
        interval: 0.1,
        numFrames: 10,
        frameDuration: 1,
        keepCameraOn: false,
        images: [],
        video: null,
        webcamVideoElement: null,
        cameraStream: null,
        text: '',
        fontWeight: 'normal',
        fontSize: '16px',
        minFontSize: '10px',
        resizeFont: false,
        fontFamily: 'sans-serif',
        fontColor: '#ffffff',
        textAlign: 'center',
        textBaseline: 'bottom',
        textXCoordinate: null,
        textYCoordinate: null,
        progressCallback: noop,
        completeCallback: noop,
        saveRenderingContexts: false,
        savedRenderingContexts: [],
        crossOrigin: 'Anonymous'
    };
    var defaultOptions$2 = Object.freeze({
        default: defaultOptions
    });
    /*
  isSupported.js
  ==============
*/ /* Copyright  2017 Yahoo Inc.
 * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.
*/ // Dependencies
    function isSupported() {
        return error.isValid();
    }
    /*
  isWebCamGIFSupported.js
  =======================
*/ /* Copyright  2017 Yahoo Inc.
 * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.
*/ function isWebCamGIFSupported() {
        return error.isValid();
    }
    /*
  isSupported.js
  ==============
*/ /* Copyright  2017 Yahoo Inc.
 * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.
*/ // Dependencies
    function isSupported$1() {
        var options = {
            getUserMedia: true
        };
        return error.isValid(options);
    }
    /*
  isExistingVideoGIFSupported.js
  ==============================
*/ /* Copyright  2017 Yahoo Inc.
 * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.
*/ // Dependencies
    function isExistingVideoGIFSupported(codecs) {
        var hasValidCodec = false;
        if (utils.isArray(codecs) && codecs.length) {
            utils.each(codecs, function(indece, currentCodec) {
                if (utils.isSupported.videoCodecs[currentCodec]) {
                    hasValidCodec = true;
                }
            });
            if (!hasValidCodec) {
                return false;
            }
        } else if (utils.isString(codecs) && codecs.length) {
            if (!utils.isSupported.videoCodecs[codecs]) {
                return false;
            }
        }
        return error.isValid({
            'getUserMedia': true
        });
    }
    /*
  NeuQuant.js
  ===========
*/ /*
 * NeuQuant Neural-Net Quantization Algorithm
 * ------------------------------------------
 *
 * Copyright (c) 1994 Anthony Dekker
 *
 * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See
 * "Kohonen neural networks for optimal colour quantization" in "Network:
 * Computation in Neural Systems" Vol. 5 (1994) pp 351-367. for a discussion of
 * the algorithm.
 *
 * Any party obtaining a copy of these files from the author, directly or
 * indirectly, is granted, free of charge, a full and unrestricted irrevocable,
 * world-wide, paid up, royalty-free, nonexclusive right and license to deal in
 * this software and documentation files (the "Software"), including without
 * limitation the rights to use, copy, modify, merge, publish, distribute,
 * sublicense, and/or sell copies of the Software, and to permit persons who
 * receive copies from any such party to do so, with the only requirement being
 * that this copyright notice remain intact.
 */ /*
 * This class handles Neural-Net quantization algorithm
 * @author Kevin Weiner (original Java version - kweiner@fmsware.com)
 * @author Thibault Imbert (AS3 version - bytearray.org)
 * @version 0.1 AS3 implementation
 * @version 0.2 JS->AS3 "translation" by antimatter15
 * @version 0.3 JS clean up + using modern JS idioms by sole - http://soledadpenades.com
 * Also implement fix in color conversion described at http://stackoverflow.com/questions/16371712/neuquant-js-javascript-color-quantization-hidden-bug-in-js-conversion
 */ function NeuQuant() {
        var netsize = 256; // number of colours used
        // four primes near 500 - assume no image has a length so large
        // that it is divisible by all four primes
        var prime1 = 499;
        var prime2 = 491;
        var prime3 = 487;
        var prime4 = 503;
        // minimum size for input image
        var minpicturebytes = 3 * prime4;
        // Network Definitions
        var maxnetpos = netsize - 1;
        var netbiasshift = 4; // bias for colour values
        var ncycles = 100; // no. of learning cycles
        // defs for freq and bias
        var intbiasshift = 16; // bias for fractions
        var intbias = 1 << intbiasshift;
        var gammashift = 10; // gamma = 1024
        var gamma = 1 << gammashift;
        var betashift = 10;
        var beta = intbias >> betashift; // beta = 1/1024
        var betagamma = intbias << gammashift - betashift;
        // defs for decreasing radius factor
        // For 256 colors, radius starts at 32.0 biased by 6 bits
        // and decreases by a factor of 1/30 each cycle
        var initrad = netsize >> 3;
        var radiusbiasshift = 6;
        var radiusbias = 1 << radiusbiasshift;
        var initradius = initrad * radiusbias;
        var radiusdec = 30;
        // defs for decreasing alpha factor
        // Alpha starts at 1.0 biased by 10 bits
        var alphabiasshift = 10;
        var initalpha = 1 << alphabiasshift;
        var alphadec;
        // radbias and alpharadbias used for radpower calculation
        var radbiasshift = 8;
        var radbias = 1 << radbiasshift;
        var alpharadbshift = alphabiasshift + radbiasshift;
        var alpharadbias = 1 << alpharadbshift;
        // Input image
        var thepicture;
        // Height * Width * 3
        var lengthcount;
        // Sampling factor 1..30
        var samplefac;
        // The network itself
        var network;
        var netindex = [];
        // for network lookup - really 256
        var bias = [];
        // bias and freq arrays for learning
        var freq = [];
        var radpower = [];
        function NeuQuantConstructor(thepic, len, sample) {
            var i;
            var p;
            thepicture = thepic;
            lengthcount = len;
            samplefac = sample;
            network = new Array(netsize);
            for(i = 0; i < netsize; i++){
                network[i] = new Array(4);
                p = network[i];
                p[0] = p[1] = p[2] = (i << netbiasshift + 8) / netsize | 0;
                freq[i] = intbias / netsize | 0; // 1 / netsize
                bias[i] = 0;
            }
        }
        function colorMap() {
            var map = [];
            var index = new Array(netsize);
            for(var i = 0; i < netsize; i++){
                index[network[i][3]] = i;
            }
            var k = 0;
            for(var l = 0; l < netsize; l++){
                var j = index[l];
                map[k++] = network[j][0];
                map[k++] = network[j][1];
                map[k++] = network[j][2];
            }
            return map;
        }
        // Insertion sort of network and building of netindex[0..255]
        // (to do after unbias)
        function inxbuild() {
            var i;
            var j;
            var smallpos;
            var smallval;
            var p;
            var q;
            var previouscol;
            var startpos;
            previouscol = 0;
            startpos = 0;
            for(i = 0; i < netsize; i++){
                p = network[i];
                smallpos = i;
                smallval = p[1]; // index on g
                // find smallest in i..netsize-1
                for(j = i + 1; j < netsize; j++){
                    q = network[j];
                    if (q[1] < smallval) {
                        // index on g
                        smallpos = j;
                        smallval = q[1]; // index on g
                    }
                }
                q = network[smallpos];
                // swap p (i) and q (smallpos) entries
                if (i != smallpos) {
                    j = q[0];
                    q[0] = p[0];
                    p[0] = j;
                    j = q[1];
                    q[1] = p[1];
                    p[1] = j;
                    j = q[2];
                    q[2] = p[2];
                    p[2] = j;
                    j = q[3];
                    q[3] = p[3];
                    p[3] = j;
                }
                // smallval entry is now in position i
                if (smallval != previouscol) {
                    netindex[previouscol] = startpos + i >> 1;
                    for(j = previouscol + 1; j < smallval; j++){
                        netindex[j] = i;
                    }
                    previouscol = smallval;
                    startpos = i;
                }
            }
            netindex[previouscol] = startpos + maxnetpos >> 1;
            for(j = previouscol + 1; j < 256; j++){
                netindex[j] = maxnetpos; // really 256
            }
        }
        // Main Learning Loop
        function learn() {
            var i;
            var j;
            var b;
            var g;
            var r;
            var radius;
            var rad;
            var alpha;
            var step;
            var delta;
            var samplepixels;
            var p;
            var pix;
            var lim;
            if (lengthcount < minpicturebytes) {
                samplefac = 1;
            }
            alphadec = 30 + (samplefac - 1) / 3;
            p = thepicture;
            pix = 0;
            lim = lengthcount;
            samplepixels = lengthcount / (3 * samplefac);
            delta = samplepixels / ncycles | 0;
            alpha = initalpha;
            radius = initradius;
            rad = radius >> radiusbiasshift;
            if (rad <= 1) {
                rad = 0;
            }
            for(i = 0; i < rad; i++){
                radpower[i] = alpha * ((rad * rad - i * i) * radbias / (rad * rad));
            }
            if (lengthcount < minpicturebytes) {
                step = 3;
            } else if (lengthcount % prime1 !== 0) {
                step = 3 * prime1;
            } else {
                if (lengthcount % prime2 !== 0) {
                    step = 3 * prime2;
                } else {
                    if (lengthcount % prime3 !== 0) {
                        step = 3 * prime3;
                    } else {
                        step = 3 * prime4;
                    }
                }
            }
            i = 0;
            while(i < samplepixels){
                b = (p[pix + 0] & 0xff) << netbiasshift;
                g = (p[pix + 1] & 0xff) << netbiasshift;
                r = (p[pix + 2] & 0xff) << netbiasshift;
                j = contest(b, g, r);
                altersingle(alpha, j, b, g, r);
                if (rad !== 0) {
                    // Alter neighbours
                    alterneigh(rad, j, b, g, r);
                }
                pix += step;
                if (pix >= lim) {
                    pix -= lengthcount;
                }
                i++;
                if (delta === 0) {
                    delta = 1;
                }
                if (i % delta === 0) {
                    alpha -= alpha / alphadec;
                    radius -= radius / radiusdec;
                    rad = radius >> radiusbiasshift;
                    if (rad <= 1) {
                        rad = 0;
                    }
                    for(j = 0; j < rad; j++){
                        radpower[j] = alpha * ((rad * rad - j * j) * radbias / (rad * rad));
                    }
                }
            }
        }
        // Search for BGR values 0..255 (after net is unbiased) and return colour index
        function map(b, g, r) {
            var i;
            var j;
            var dist;
            var a;
            var bestd;
            var p;
            var best;
            // Biggest possible distance is 256 * 3
            bestd = 1000;
            best = -1;
            i = netindex[g]; // index on g
            j = i - 1; // start at netindex[g] and work outwards
            while(i < netsize || j >= 0){
                if (i < netsize) {
                    p = network[i];
                    dist = p[1] - g; // inx key
                    if (dist >= bestd) {
                        i = netsize; // stop iter
                    } else {
                        i++;
                        if (dist < 0) {
                            dist = -dist;
                        }
                        a = p[0] - b;
                        if (a < 0) {
                            a = -a;
                        }
                        dist += a;
                        if (dist < bestd) {
                            a = p[2] - r;
                            if (a < 0) {
                                a = -a;
                            }
                            dist += a;
                            if (dist < bestd) {
                                bestd = dist;
                                best = p[3];
                            }
                        }
                    }
                }
                if (j >= 0) {
                    p = network[j];
                    dist = g - p[1]; // inx key - reverse dif
                    if (dist >= bestd) {
                        j = -1; // stop iter
                    } else {
                        j--;
                        if (dist < 0) {
                            dist = -dist;
                        }
                        a = p[0] - b;
                        if (a < 0) {
                            a = -a;
                        }
                        dist += a;
                        if (dist < bestd) {
                            a = p[2] - r;
                            if (a < 0) {
                                a = -a;
                            }
                            dist += a;
                            if (dist < bestd) {
                                bestd = dist;
                                best = p[3];
                            }
                        }
                    }
                }
            }
            return best;
        }
        function process() {
            learn();
            unbiasnet();
            inxbuild();
            return colorMap();
        }
        // Unbias network to give byte values 0..255 and record position i
        // to prepare for sort
        function unbiasnet() {
            var i;
            var j;
            for(i = 0; i < netsize; i++){
                network[i][0] >>= netbiasshift;
                network[i][1] >>= netbiasshift;
                network[i][2] >>= netbiasshift;
                network[i][3] = i; // record colour no
            }
        }
        // Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2))
        // in radpower[|i-j|]
        function alterneigh(rad, i, b, g, r) {
            var j;
            var k;
            var lo;
            var hi;
            var a;
            var m;
            var p;
            lo = i - rad;
            if (lo < -1) {
                lo = -1;
            }
            hi = i + rad;
            if (hi > netsize) {
                hi = netsize;
            }
            j = i + 1;
            k = i - 1;
            m = 1;
            while(j < hi || k > lo){
                a = radpower[m++];
                if (j < hi) {
                    p = network[j++];
                    try {
                        p[0] -= a * (p[0] - b) / alpharadbias | 0;
                        p[1] -= a * (p[1] - g) / alpharadbias | 0;
                        p[2] -= a * (p[2] - r) / alpharadbias | 0;
                    } catch (e) {}
                }
                if (k > lo) {
                    p = network[k--];
                    try {
                        p[0] -= a * (p[0] - b) / alpharadbias | 0;
                        p[1] -= a * (p[1] - g) / alpharadbias | 0;
                        p[2] -= a * (p[2] - r) / alpharadbias | 0;
                    } catch (e) {}
                }
            }
        }
        // Move neuron i towards biased (b,g,r) by factor alpha
        function altersingle(alpha, i, b, g, r) {
            // alter hit neuron
            var n = network[i];
            var alphaMult = alpha / initalpha;
            n[0] -= alphaMult * (n[0] - b) | 0;
            n[1] -= alphaMult * (n[1] - g) | 0;
            n[2] -= alphaMult * (n[2] - r) | 0;
        }
        // Search for biased BGR values
        function contest(b, g, r) {
            // finds closest neuron (min dist) and updates freq
            // finds best neuron (min dist-bias) and returns position
            // for frequently chosen neurons, freq[i] is high and bias[i] is negative
            // bias[i] = gamma*((1/netsize)-freq[i])
            var i;
            var dist;
            var a;
            var biasdist;
            var betafreq;
            var bestpos;
            var bestbiaspos;
            var bestd;
            var bestbiasd;
            var n;
            bestd = ~(1 << 31);
            bestbiasd = bestd;
            bestpos = -1;
            bestbiaspos = bestpos;
            for(i = 0; i < netsize; i++){
                n = network[i];
                dist = n[0] - b;
                if (dist < 0) {
                    dist = -dist;
                }
                a = n[1] - g;
                if (a < 0) {
                    a = -a;
                }
                dist += a;
                a = n[2] - r;
                if (a < 0) {
                    a = -a;
                }
                dist += a;
                if (dist < bestd) {
                    bestd = dist;
                    bestpos = i;
                }
                biasdist = dist - (bias[i] >> intbiasshift - netbiasshift);
                if (biasdist < bestbiasd) {
                    bestbiasd = biasdist;
                    bestbiaspos = i;
                }
                betafreq = freq[i] >> betashift;
                freq[i] -= betafreq;
                bias[i] += betafreq << gammashift;
            }
            freq[bestpos] += beta;
            bias[bestpos] -= betagamma;
            return bestbiaspos;
        }
        NeuQuantConstructor.apply(this, arguments);
        var exports = {};
        exports.map = map;
        exports.process = process;
        return exports;
    }
    /*
  processFrameWorker.js
  =====================
*/ /* Copyright  2017 Yahoo Inc.
 * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.
*/ function workerCode() {
        var self = this;
        try {
            self.onmessage = function(ev) {
                var data = ev.data || {};
                var response;
                if (data.gifshot) {
                    response = workerMethods.run(data);
                    postMessage(response);
                }
            };
        } catch (e) {}
        var workerMethods = {
            dataToRGB: function dataToRGB(data, width, height) {
                var length = width * height * 4;
                var i = 0;
                var rgb = [];
                while(i < length){
                    rgb.push(data[i++]);
                    rgb.push(data[i++]);
                    rgb.push(data[i++]);
                    i++; // for the alpha channel which we don't care about
                }
                return rgb;
            },
            componentizedPaletteToArray: function componentizedPaletteToArray(paletteRGB) {
                paletteRGB = paletteRGB || [];
                var paletteArray = [];
                for(var i = 0; i < paletteRGB.length; i += 3){
                    var r = paletteRGB[i];
                    var g = paletteRGB[i + 1];
                    var b = paletteRGB[i + 2];
                    paletteArray.push(r << 16 | g << 8 | b);
                }
                return paletteArray;
            },
            // This is the "traditional" Animated_GIF style of going from RGBA to indexed color frames
            'processFrameWithQuantizer': function processFrameWithQuantizer(imageData, width, height, sampleInterval) {
                var rgbComponents = this.dataToRGB(imageData, width, height);
                var nq = new NeuQuant(rgbComponents, rgbComponents.length, sampleInterval);
                var paletteRGB = nq.process();
                var paletteArray = new Uint32Array(this.componentizedPaletteToArray(paletteRGB));
                var numberPixels = width * height;
                var indexedPixels = new Uint8Array(numberPixels);
                var k = 0;
                for(var i = 0; i < numberPixels; i++){
                    var r = rgbComponents[k++];
                    var g = rgbComponents[k++];
                    var b = rgbComponents[k++];
                    indexedPixels[i] = nq.map(r, g, b);
                }
                return {
                    pixels: indexedPixels,
                    palette: paletteArray
                };
            },
            'run': function run(frame) {
                frame = frame || {};
                var _frame = frame, height = _frame.height, palette = _frame.palette, sampleInterval = _frame.sampleInterval, width = _frame.width;
                var imageData = frame.data;
                return this.processFrameWithQuantizer(imageData, width, height, sampleInterval);
            }
        };
        return workerMethods;
    }
    /*
  gifWriter.js
  ============
*/ // (c) Dean McNamee <dean@gmail.com>, 2013.
    //
    // https://github.com/deanm/omggif
    //
    // Permission is hereby granted, free of charge, to any person obtaining a copy
    // of this software and associated documentation files (the "Software"), to
    // deal in the Software without restriction, including without limitation the
    // rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
    // sell copies of the Software, and to permit persons to whom the Software is
    // furnished to do so, subject to the following conditions:
    //
    // The above copyright notice and this permission notice shall be included in
    // all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    // FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
    // IN THE SOFTWARE.
    //
    // omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
    // including animation and compression.  It does not rely on any specific
    // underlying system, so should run in the browser, Node, or Plask.
    function gifWriter(buf, width, height, gopts) {
        var p = 0;
        gopts = gopts === undefined ? {} : gopts;
        var loop_count = gopts.loop === undefined ? null : gopts.loop;
        var global_palette = gopts.palette === undefined ? null : gopts.palette;
        if (width <= 0 || height <= 0 || width > 65535 || height > 65535) throw "Width/Height invalid.";
        function check_palette_and_num_colors(palette) {
            var num_colors = palette.length;
            if (num_colors < 2 || num_colors > 256 || num_colors & num_colors - 1) throw "Invalid code/color length, must be power of 2 and 2 .. 256.";
            return num_colors;
        }
        // - Header.
        buf[p++] = 0x47;
        buf[p++] = 0x49;
        buf[p++] = 0x46; // GIF
        buf[p++] = 0x38;
        buf[p++] = 0x39;
        buf[p++] = 0x61; // 89a
        // Handling of Global Color Table (palette) and background index.
        var gp_num_colors_pow2 = 0;
        var background = 0;
        // - Logical Screen Descriptor.
        // NOTE(deanm): w/h apparently ignored by implementations, but set anyway.
        buf[p++] = width & 0xff;
        buf[p++] = width >> 8 & 0xff;
        buf[p++] = height & 0xff;
        buf[p++] = height >> 8 & 0xff;
        // NOTE: Indicates 0-bpp original color resolution (unused?).
        buf[p++] = (global_palette !== null ? 0x80 : 0) | // Global Color Table Flag.
        gp_num_colors_pow2; // NOTE: No sort flag (unused?).
        buf[p++] = background; // Background Color Index.
        buf[p++] = 0; // Pixel aspect ratio (unused?).
        if (loop_count !== null) {
            // Netscape block for looping.
            if (loop_count < 0 || loop_count > 65535) throw "Loop count invalid.";
            // Extension code, label, and length.
            buf[p++] = 0x21;
            buf[p++] = 0xff;
            buf[p++] = 0x0b;
            // NETSCAPE2.0
            buf[p++] = 0x4e;
            buf[p++] = 0x45;
            buf[p++] = 0x54;
            buf[p++] = 0x53;
            buf[p++] = 0x43;
            buf[p++] = 0x41;
            buf[p++] = 0x50;
            buf[p++] = 0x45;
            buf[p++] = 0x32;
            buf[p++] = 0x2e;
            buf[p++] = 0x30;
            // Sub-block
            buf[p++] = 0x03;
            buf[p++] = 0x01;
            buf[p++] = loop_count & 0xff;
            buf[p++] = loop_count >> 8 & 0xff;
            buf[p++] = 0x00; // Terminator.
        }
        var ended = false;
        this.addFrame = function(x, y, w, h, indexed_pixels, opts) {
            if (ended === true) {
                --p;
                ended = false;
            } // Un-end.
            opts = opts === undefined ? {} : opts;
            // TODO(deanm): Bounds check x, y.  Do they need to be within the virtual
            // canvas width/height, I imagine?
            if (x < 0 || y < 0 || x > 65535 || y > 65535) throw "x/y invalid.";
            if (w <= 0 || h <= 0 || w > 65535 || h > 65535) throw "Width/Height invalid.";
            if (indexed_pixels.length < w * h) throw "Not enough pixels for the frame size.";
            var using_local_palette = true;
            var palette = opts.palette;
            if (palette === undefined || palette === null) {
                using_local_palette = false;
                palette = global_palette;
            }
            if (palette === undefined || palette === null) throw "Must supply either a local or global palette.";
            var num_colors = check_palette_and_num_colors(palette);
            // Compute the min_code_size (power of 2), destroying num_colors.
            var min_code_size = 0;
            while(num_colors >>= 1){
                ++min_code_size;
            }
            num_colors = 1 << min_code_size; // Now we can easily get it back.
            var delay = opts.delay === undefined ? 0 : opts.delay;
            // From the spec:
            //     0 -   No disposal specified. The decoder is
            //           not required to take any action.
            //     1 -   Do not dispose. The graphic is to be left
            //           in place.
            //     2 -   Restore to background color. The area used by the
            //           graphic must be restored to the background color.
            //     3 -   Restore to previous. The decoder is required to
            //           restore the area overwritten by the graphic with
            //           what was there prior to rendering the graphic.
            //  4-7 -    To be defined.
            // NOTE(deanm): Dispose background doesn't really work, apparently most
            // browsers ignore the background palette index and clear to transparency.
            var disposal = opts.disposal === undefined ? 0 : opts.disposal;
            if (disposal < 0 || disposal > 3) throw "Disposal out of range.";
            var use_transparency = false;
            var transparent_index = 0;
            if (opts.transparent !== undefined && opts.transparent !== null) {
                use_transparency = true;
                transparent_index = opts.transparent;
                if (transparent_index < 0 || transparent_index >= num_colors) throw "Transparent color index.";
            }
            if (disposal !== 0 || use_transparency || delay !== 0) {
                // - Graphics Control Extension
                buf[p++] = 0x21;
                buf[p++] = 0xf9; // Extension / Label.
                buf[p++] = 4; // Byte size.
                buf[p++] = disposal << 2 | (use_transparency === true ? 1 : 0);
                buf[p++] = delay & 0xff;
                buf[p++] = delay >> 8 & 0xff;
                buf[p++] = transparent_index; // Transparent color index.
                buf[p++] = 0; // Block Terminator.
            }
            // - Image Descriptor
            buf[p++] = 0x2c; // Image Seperator.
            buf[p++] = x & 0xff;
            buf[p++] = x >> 8 & 0xff; // Left.
            buf[p++] = y & 0xff;
            buf[p++] = y >> 8 & 0xff; // Top.
            buf[p++] = w & 0xff;
            buf[p++] = w >> 8 & 0xff;
            buf[p++] = h & 0xff;
            buf[p++] = h >> 8 & 0xff;
            // NOTE: No sort flag (unused?).
            // TODO(deanm): Support interlace.
            buf[p++] = using_local_palette === true ? 0x80 | min_code_size - 1 : 0;
            // - Local Color Table
            if (using_local_palette === true) {
                for(var i = 0, il = palette.length; i < il; ++i){
                    var rgb = palette[i];
                    buf[p++] = rgb >> 16 & 0xff;
                    buf[p++] = rgb >> 8 & 0xff;
                    buf[p++] = rgb & 0xff;
                }
            }
            p = GifWriterOutputLZWCodeStream(buf, p, min_code_size < 2 ? 2 : min_code_size, indexed_pixels);
        };
        this.end = function() {
            if (ended === false) {
                buf[p++] = 0x3b; // Trailer.
                ended = true;
            }
            return p;
        };
        // Main compression routine, palette indexes -> LZW code stream.
        // |index_stream| must have at least one entry.
        function GifWriterOutputLZWCodeStream(buf, p, min_code_size, index_stream) {
            buf[p++] = min_code_size;
            var cur_subblock = p++; // Pointing at the length field.
            var clear_code = 1 << min_code_size;
            var code_mask = clear_code - 1;
            var eoi_code = clear_code + 1;
            var next_code = eoi_code + 1;
            var cur_code_size = min_code_size + 1; // Number of bits per code.
            var cur_shift = 0;
            // We have at most 12-bit codes, so we should have to hold a max of 19
            // bits here (and then we would write out).
            var cur = 0;
            function emit_bytes_to_buffer(bit_block_size) {
                while(cur_shift >= bit_block_size){
                    buf[p++] = cur & 0xff;
                    cur >>= 8;
                    cur_shift -= 8;
                    if (p === cur_subblock + 256) {
                        // Finished a subblock.
                        buf[cur_subblock] = 255;
                        cur_subblock = p++;
                    }
                }
            }
            function emit_code(c) {
                cur |= c << cur_shift;
                cur_shift += cur_code_size;
                emit_bytes_to_buffer(8);
            }
            // I am not an expert on the topic, and I don't want to write a thesis.
            // However, it is good to outline here the basic algorithm and the few data
            // structures and optimizations here that make this implementation fast.
            // The basic idea behind LZW is to build a table of previously seen runs
            // addressed by a short id (herein called output code).  All data is
            // referenced by a code, which represents one or more values from the
            // original input stream.  All input bytes can be referenced as the same
            // value as an output code.  So if you didn't want any compression, you
            // could more or less just output the original bytes as codes (there are
            // some details to this, but it is the idea).  In order to achieve
            // compression, values greater then the input range (codes can be up to
            // 12-bit while input only 8-bit) represent a sequence of previously seen
            // inputs.  The decompressor is able to build the same mapping while
            // decoding, so there is always a shared common knowledge between the
            // encoding and decoder, which is also important for "timing" aspects like
            // how to handle variable bit width code encoding.
            //
            // One obvious but very important consequence of the table system is there
            // is always a unique id (at most 12-bits) to map the runs.  'A' might be
            // 4, then 'AA' might be 10, 'AAA' 11, 'AAAA' 12, etc.  This relationship
            // can be used for an effecient lookup strategy for the code mapping.  We
            // need to know if a run has been seen before, and be able to map that run
            // to the output code.  Since we start with known unique ids (input bytes),
            // and then from those build more unique ids (table entries), we can
            // continue this chain (almost like a linked list) to always have small
            // integer values that represent the current byte chains in the encoder.
            // This means instead of tracking the input bytes (AAAABCD) to know our
            // current state, we can track the table entry for AAAABC (it is guaranteed
            // to exist by the nature of the algorithm) and the next character D.
            // Therefor the tuple of (table_entry, byte) is guaranteed to also be
            // unique.  This allows us to create a simple lookup key for mapping input
            // sequences to codes (table indices) without having to store or search
            // any of the code sequences.  So if 'AAAA' has a table entry of 12, the
            // tuple of ('AAAA', K) for any input byte K will be unique, and can be our
            // key.  This leads to a integer value at most 20-bits, which can always
            // fit in an SMI value and be used as a fast sparse array / object key.
            // Output code for the current contents of the index buffer.
            var ib_code = index_stream[0] & code_mask; // Load first input index.
            var code_table = {}; // Key'd on our 20-bit "tuple".
            emit_code(clear_code); // Spec says first code should be a clear code.
            // First index already loaded, process the rest of the stream.
            for(var i = 1, il = index_stream.length; i < il; ++i){
                var k = index_stream[i] & code_mask;
                var cur_key = ib_code << 8 | k; // (prev, k) unique tuple.
                var cur_code = code_table[cur_key]; // buffer + k.
                // Check if we have to create a new code table entry.
                if (cur_code === undefined) {
                    // We don't have buffer + k.
                    // Emit index buffer (without k).
                    // This is an inline version of emit_code, because this is the core
                    // writing routine of the compressor (and V8 cannot inline emit_code
                    // because it is a closure here in a different context).  Additionally
                    // we can call emit_byte_to_buffer less often, because we can have
                    // 30-bits (from our 31-bit signed SMI), and we know our codes will only
                    // be 12-bits, so can safely have 18-bits there without overflow.
                    // emit_code(ib_code);
                    cur |= ib_code << cur_shift;
                    cur_shift += cur_code_size;
                    while(cur_shift >= 8){
                        buf[p++] = cur & 0xff;
                        cur >>= 8;
                        cur_shift -= 8;
                        if (p === cur_subblock + 256) {
                            // Finished a subblock.
                            buf[cur_subblock] = 255;
                            cur_subblock = p++;
                        }
                    }
                    if (next_code === 4096) {
                        // Table full, need a clear.
                        emit_code(clear_code);
                        next_code = eoi_code + 1;
                        cur_code_size = min_code_size + 1;
                        code_table = {};
                    } else {
                        // Table not full, insert a new entry.
                        // Increase our variable bit code sizes if necessary.  This is a bit
                        // tricky as it is based on "timing" between the encoding and
                        // decoder.  From the encoders perspective this should happen after
                        // we've already emitted the index buffer and are about to create the
                        // first table entry that would overflow our current code bit size.
                        if (next_code >= 1 << cur_code_size) ++cur_code_size;
                        code_table[cur_key] = next_code++; // Insert into code table.
                    }
                    ib_code = k; // Index buffer to single input k.
                } else {
                    ib_code = cur_code; // Index buffer to sequence in code table.
                }
            }
            emit_code(ib_code); // There will still be something in the index buffer.
            emit_code(eoi_code); // End Of Information.
            // Flush / finalize the sub-blocks stream to the buffer.
            emit_bytes_to_buffer(1);
            // Finish the sub-blocks, writing out any unfinished lengths and
            // terminating with a sub-block of length 0.  If we have already started
            // but not yet used a sub-block it can just become the terminator.
            if (cur_subblock + 1 === p) {
                // Started but unused.
                buf[cur_subblock] = 0;
            } else {
                // Started and used, write length and additional terminator block.
                buf[cur_subblock] = p - cur_subblock - 1;
                buf[p++] = 0;
            }
            return p;
        }
    }
    /*
  animatedGIF.js
  ==============
*/ /* Copyright  2017 Yahoo Inc.
 * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.
*/ // Dependencies
    // Helpers
    var noop$2 = function noop() {};
    var AnimatedGIF = function AnimatedGIF(options) {
        this.canvas = null;
        this.ctx = null;
        this.repeat = 0;
        this.frames = [];
        this.numRenderedFrames = 0;
        this.onRenderCompleteCallback = noop$2;
        this.onRenderProgressCallback = noop$2;
        this.workers = [];
        this.availableWorkers = [];
        this.generatingGIF = false;
        this.options = options;
        // Constructs and initializes the the web workers appropriately
        this.initializeWebWorkers(options);
    };
    AnimatedGIF.prototype = {
        'workerMethods': workerCode(),
        'initializeWebWorkers': function initializeWebWorkers(options) {
            var self = this;
            var processFrameWorkerCode = NeuQuant.toString() + '(' + workerCode.toString() + '());';
            var webWorkerObj = void 0;
            var objectUrl = void 0;
            var webWorker = void 0;
            var numWorkers = void 0;
            var x = -1;
            var workerError = '';
            numWorkers = options.numWorkers;
            while(++x < numWorkers){
                webWorkerObj = utils.createWebWorker(processFrameWorkerCode);
                if (utils.isObject(webWorkerObj)) {
                    objectUrl = webWorkerObj.objectUrl;
                    webWorker = webWorkerObj.worker;
                    self.workers.push({
                        worker: webWorker,
                        objectUrl: objectUrl
                    });
                    self.availableWorkers.push(webWorker);
                } else {
                    workerError = webWorkerObj;
                    utils.webWorkerError = !!webWorkerObj;
                }
            }
            this.workerError = workerError;
            this.canvas = document1.createElement('canvas');
            this.canvas.width = options.gifWidth;
            this.canvas.height = options.gifHeight;
            this.ctx = this.canvas.getContext('2d');
            this.frames = [];
        },
        // Return a worker for processing a frame
        getWorker: function getWorker() {
            return this.availableWorkers.pop();
        },
        // Restores a worker to the pool
        freeWorker: function freeWorker(worker) {
            this.availableWorkers.push(worker);
        },
        byteMap: function() {
            var byteMap = [];
            for(var i = 0; i < 256; i++){
                byteMap[i] = String.fromCharCode(i);
            }
            return byteMap;
        }(),
        bufferToString: function bufferToString(buffer) {
            var numberValues = buffer.length;
            var str = '';
            var x = -1;
            while(++x < numberValues){
                str += this.byteMap[buffer[x]];
            }
            return str;
        },
        onFrameFinished: function onFrameFinished(progressCallback) {
            // The GIF is not written until we're done with all the frames
            // because they might not be processed in the same order
            var self = this;
            var frames = self.frames;
            var options = self.options;
            var hasExistingImages = !!(options.images || []).length;
            var allDone = frames.every(function(frame) {
                return !frame.beingProcessed && frame.done;
            });
            self.numRenderedFrames++;
            if (hasExistingImages) {
                progressCallback(self.numRenderedFrames / frames.length);
            }
            self.onRenderProgressCallback(self.numRenderedFrames * 0.75 / frames.length);
            if (allDone) {
                if (!self.generatingGIF) {
                    self.generateGIF(frames, self.onRenderCompleteCallback);
                }
            } else {
                utils.requestTimeout(function() {
                    self.processNextFrame();
                }, 1);
            }
        },
        processFrame: function processFrame(position) {
            var AnimatedGifContext = this;
            var options = this.options;
            var _options = this.options, progressCallback = _options.progressCallback, sampleInterval = _options.sampleInterval;
            var frames = this.frames;
            var frame = void 0;
            var worker = void 0;
            var done = function done() {
                var ev = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                var data = ev.data;
                // Delete original data, and free memory
                delete frame.data;
                frame.pixels = Array.prototype.slice.call(data.pixels);
                frame.palette = Array.prototype.slice.call(data.palette);
                frame.done = true;
                frame.beingProcessed = false;
                AnimatedGifContext.freeWorker(worker);
                AnimatedGifContext.onFrameFinished(progressCallback);
            };
            frame = frames[position];
            if (frame.beingProcessed || frame.done) {
                this.onFrameFinished();
                return;
            }
            frame.sampleInterval = sampleInterval;
            frame.beingProcessed = true;
            frame.gifshot = true;
            worker = this.getWorker();
            if (worker) {
                // Process the frame in a web worker
                worker.onmessage = done;
                worker.postMessage(frame);
            } else {
                // Process the frame in the current thread
                done({
                    'data': AnimatedGifContext.workerMethods.run(frame)
                });
            }
        },
        startRendering: function startRendering(completeCallback) {
            this.onRenderCompleteCallback = completeCallback;
            for(var i = 0; i < this.options.numWorkers && i < this.frames.length; i++){
                this.processFrame(i);
            }
        },
        processNextFrame: function processNextFrame() {
            var position = -1;
            for(var i = 0; i < this.frames.length; i++){
                var frame = this.frames[i];
                if (!frame.done && !frame.beingProcessed) {
                    position = i;
                    break;
                }
            }
            if (position >= 0) {
                this.processFrame(position);
            }
        },
        // Takes the already processed data in frames and feeds it to a new
        // GifWriter instance in order to get the binary GIF file
        generateGIF: function generateGIF(frames, callback) {
            // TODO: Weird: using a simple JS array instead of a typed array,
            // the files are WAY smaller o_o. Patches/explanations welcome!
            var buffer = []; // new Uint8Array(width * height * frames.length * 5);
            var gifOptions = {
                loop: this.repeat
            };
            var options = this.options;
            var interval = options.interval;
            var frameDuration = options.frameDuration;
            var existingImages = options.images;
            var hasExistingImages = !!existingImages.length;
            var height = options.gifHeight;
            var width = options.gifWidth;
            var gifWriter$$1 = new gifWriter(buffer, width, height, gifOptions);
            var onRenderProgressCallback = this.onRenderProgressCallback;
            var delay = hasExistingImages ? interval * 100 : 0;
            var bufferToString = void 0;
            var gif = void 0;
            this.generatingGIF = true;
            utils.each(frames, function(iterator, frame) {
                var framePalette = frame.palette;
                onRenderProgressCallback(0.75 + 0.25 * frame.position * 1.0 / frames.length);
                for(var i = 0; i < frameDuration; i++){
                    gifWriter$$1.addFrame(0, 0, width, height, frame.pixels, {
                        palette: framePalette,
                        delay: delay
                    });
                }
            });
            gifWriter$$1.end();
            onRenderProgressCallback(1.0);
            this.frames = [];
            this.generatingGIF = false;
            if (utils.isFunction(callback)) {
                bufferToString = this.bufferToString(buffer);
                gif = 'data:image/gif;base64,' + utils.btoa(bufferToString);
                callback(gif);
            }
        },
        // From GIF: 0 = loop forever, null = not looping, n > 0 = loop n times and stop
        setRepeat: function setRepeat(r) {
            this.repeat = r;
        },
        addFrame: function addFrame(element, gifshotOptions) {
            gifshotOptions = utils.isObject(gifshotOptions) ? gifshotOptions : {};
            var self = this;
            var ctx = self.ctx;
            var options = self.options;
            var width = options.gifWidth;
            var height = options.gifHeight;
            var fontSize = utils.getFontSize(gifshotOptions);
            var _gifshotOptions = gifshotOptions, filter = _gifshotOptions.filter, fontColor = _gifshotOptions.fontColor, fontFamily = _gifshotOptions.fontFamily, fontWeight = _gifshotOptions.fontWeight, gifHeight = _gifshotOptions.gifHeight, gifWidth = _gifshotOptions.gifWidth, text = _gifshotOptions.text, textAlign = _gifshotOptions.textAlign, textBaseline = _gifshotOptions.textBaseline;
            var textXCoordinate = gifshotOptions.textXCoordinate ? gifshotOptions.textXCoordinate : textAlign === 'left' ? 1 : textAlign === 'right' ? width : width / 2;
            var textYCoordinate = gifshotOptions.textYCoordinate ? gifshotOptions.textYCoordinate : textBaseline === 'top' ? 1 : textBaseline === 'center' ? height / 2 : height;
            var font = fontWeight + ' ' + fontSize + ' ' + fontFamily;
            var imageData = void 0;
            try {
                ctx.filter = filter;
                ctx.drawImage(element, 0, 0, width, height);
                if (text) {
                    ctx.font = font;
                    ctx.fillStyle = fontColor;
                    ctx.textAlign = textAlign;
                    ctx.textBaseline = textBaseline;
                    ctx.fillText(text, textXCoordinate, textYCoordinate);
                }
                imageData = ctx.getImageData(0, 0, width, height);
                self.addFrameImageData(imageData);
            } catch (e) {
                return '' + e;
            }
        },
        addFrameImageData: function addFrameImageData() {
            var imageData = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var frames = this.frames;
            var imageDataArray = imageData.data;
            this.frames.push({
                'data': imageDataArray,
                'width': imageData.width,
                'height': imageData.height,
                'palette': null,
                'dithering': null,
                'done': false,
                'beingProcessed': false,
                'position': frames.length
            });
        },
        onRenderProgress: function onRenderProgress(callback) {
            this.onRenderProgressCallback = callback;
        },
        isRendering: function isRendering() {
            return this.generatingGIF;
        },
        getBase64GIF: function getBase64GIF(completeCallback) {
            var self = this;
            var onRenderComplete = function onRenderComplete(gif) {
                self.destroyWorkers();
                utils.requestTimeout(function() {
                    completeCallback(gif);
                }, 0);
            };
            self.startRendering(onRenderComplete);
        },
        destroyWorkers: function destroyWorkers() {
            if (this.workerError) {
                return;
            }
            var workers = this.workers;
            // Explicitly ask web workers to die so they are explicitly GC'ed
            utils.each(workers, function(iterator, workerObj) {
                var worker = workerObj.worker;
                var objectUrl = workerObj.objectUrl;
                worker.terminate();
                utils.URL.revokeObjectURL(objectUrl);
            });
        }
    };
    /*
  getBase64GIF.js
  ===============
*/ /* Copyright  2017 Yahoo Inc.
 * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.
*/ function getBase64GIF(animatedGifInstance, callback) {
        // This is asynchronous, rendered with WebWorkers
        animatedGifInstance.getBase64GIF(function(image) {
            callback({
                error: false,
                errorCode: '',
                errorMsg: '',
                image: image
            });
        });
    }
    /*
  existingImages.js
  =================
*/ /* Copyright  2017 Yahoo Inc.
 * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.
*/ function existingImages() {
        var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var self = this;
        var callback = obj.callback, images = obj.images, options = obj.options;
        var imagesLength = obj.imagesLength;
        var skipObj = {
            'getUserMedia': true,
            'window.URL': true
        };
        var errorObj = error.validate(skipObj);
        var loadedImages = [];
        var loadedImagesLength = 0;
        var tempImage = void 0;
        var ag = void 0;
        if (errorObj.error) {
            return callback(errorObj);
        }
        // change workerPath to point to where Animated_GIF.worker.js is
        ag = new AnimatedGIF(options);
        utils.each(images, function(index, image) {
            var currentImage = image;
            if (image.src) {
                currentImage = currentImage.src;
            }
            if (utils.isElement(currentImage)) {
                if (options.crossOrigin) {
                    currentImage.crossOrigin = options.crossOrigin;
                }
                loadedImages[index] = currentImage;
                loadedImagesLength += 1;
                if (loadedImagesLength === imagesLength) {
                    addLoadedImagesToGif();
                }
            } else if (utils.isString(currentImage)) {
                tempImage = new Image();
                if (options.crossOrigin) {
                    tempImage.crossOrigin = options.crossOrigin;
                }
                (function(tempImage) {
                    if (image.text) {
                        tempImage.text = image.text;
                    }
                    tempImage.onerror = function(e) {
                        var obj = void 0;
                        --imagesLength; // skips over images that error out
                        if (imagesLength === 0) {
                            obj = {};
                            obj.error = 'None of the requested images was capable of being retrieved';
                            return callback(obj);
                        }
                    };
                    tempImage.onload = function(e) {
                        if (image.text) {
                            loadedImages[index] = {
                                img: tempImage,
                                text: tempImage.text
                            };
                        } else {
                            loadedImages[index] = tempImage;
                        }
                        loadedImagesLength += 1;
                        if (loadedImagesLength === imagesLength) {
                            addLoadedImagesToGif();
                        }
                        utils.removeElement(tempImage);
                    };
                    tempImage.src = currentImage;
                })(tempImage);
                utils.setCSSAttr(tempImage, {
                    position: 'fixed',
                    opacity: '0'
                });
                document1.body.appendChild(tempImage);
            }
        });
        function addLoadedImagesToGif() {
            utils.each(loadedImages, function(index, loadedImage) {
                if (loadedImage) {
                    if (loadedImage.text) {
                        ag.addFrame(loadedImage.img, options, loadedImage.text);
                    } else {
                        ag.addFrame(loadedImage, options);
                    }
                }
            });
            getBase64GIF(ag, callback);
        }
    }
    /*
  screenShot.js
  =============
*/ /* Copyright  2017 Yahoo Inc.
 * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.
*/ // Dependencies
    // Helpers
    var noop$3 = function noop() {};
    var screenShot = {
        getGIF: function getGIF() {
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var callback = arguments[1];
            callback = utils.isFunction(callback) ? callback : noop$3;
            var canvas = document1.createElement('canvas');
            var context = void 0;
            var existingImages = options.images;
            var hasExistingImages = !!existingImages.length;
            var cameraStream = options.cameraStream, crop = options.crop, filter = options.filter, fontColor = options.fontColor, fontFamily = options.fontFamily, fontWeight = options.fontWeight, keepCameraOn = options.keepCameraOn, numWorkers = options.numWorkers, progressCallback = options.progressCallback, saveRenderingContexts = options.saveRenderingContexts, savedRenderingContexts = options.savedRenderingContexts, text = options.text, textAlign = options.textAlign, textBaseline = options.textBaseline, videoElement = options.videoElement, videoHeight = options.videoHeight, videoWidth = options.videoWidth, webcamVideoElement = options.webcamVideoElement;
            var gifWidth = Number(options.gifWidth);
            var gifHeight = Number(options.gifHeight);
            var interval = Number(options.interval);
            var sampleInterval = Number(options.sampleInterval);
            var waitBetweenFrames = hasExistingImages ? 0 : interval * 1000;
            var renderingContextsToSave = [];
            var numFrames = savedRenderingContexts.length ? savedRenderingContexts.length : options.numFrames;
            var pendingFrames = numFrames;
            var ag = new AnimatedGIF(options);
            var fontSize = utils.getFontSize(options);
            var textXCoordinate = options.textXCoordinate ? options.textXCoordinate : textAlign === 'left' ? 1 : textAlign === 'right' ? gifWidth : gifWidth / 2;
            var textYCoordinate = options.textYCoordinate ? options.textYCoordinate : textBaseline === 'top' ? 1 : textBaseline === 'center' ? gifHeight / 2 : gifHeight;
            var font = fontWeight + ' ' + fontSize + ' ' + fontFamily;
            var sourceX = crop ? Math.floor(crop.scaledWidth / 2) : 0;
            var sourceWidth = crop ? videoWidth - crop.scaledWidth : 0;
            var sourceY = crop ? Math.floor(crop.scaledHeight / 2) : 0;
            var sourceHeight = crop ? videoHeight - crop.scaledHeight : 0;
            var captureFrames = function captureSingleFrame() {
                var framesLeft = pendingFrames - 1;
                if (savedRenderingContexts.length) {
                    context.putImageData(savedRenderingContexts[numFrames - pendingFrames], 0, 0);
                    finishCapture();
                } else {
                    drawVideo();
                }
                function drawVideo() {
                    try {
                        // Makes sure the canvas video heights/widths are in bounds
                        if (sourceWidth > videoWidth) {
                            sourceWidth = videoWidth;
                        }
                        if (sourceHeight > videoHeight) {
                            sourceHeight = videoHeight;
                        }
                        if (sourceX < 0) {
                            sourceX = 0;
                        }
                        if (sourceY < 0) {
                            sourceY = 0;
                        }
                        context.filter = filter;
                        context.drawImage(videoElement, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, gifWidth, gifHeight);
                        finishCapture();
                    } catch (e) {
                        // There is a Firefox bug that sometimes throws NS_ERROR_NOT_AVAILABLE and
                        // and IndexSizeError errors when drawing a video element to the canvas
                        if (e.name === 'NS_ERROR_NOT_AVAILABLE') {
                            // Wait 100ms before trying again
                            utils.requestTimeout(drawVideo, 100);
                        } else {
                            throw e;
                        }
                    }
                }
                function finishCapture() {
                    var imageData = void 0;
                    if (saveRenderingContexts) {
                        renderingContextsToSave.push(context.getImageData(0, 0, gifWidth, gifHeight));
                    }
                    // If there is text to display, make sure to display it on the canvas after the image is drawn
                    if (text) {
                        context.font = font;
                        context.fillStyle = fontColor;
                        context.textAlign = textAlign;
                        context.textBaseline = textBaseline;
                        context.fillText(text, textXCoordinate, textYCoordinate);
                    }
                    imageData = context.getImageData(0, 0, gifWidth, gifHeight);
                    ag.addFrameImageData(imageData);
                    pendingFrames = framesLeft;
                    // Call back with an r value indicating how far along we are in capture
                    progressCallback((numFrames - pendingFrames) / numFrames);
                    if (framesLeft > 0) {
                        // test
                        utils.requestTimeout(captureSingleFrame, waitBetweenFrames);
                    }
                    if (!pendingFrames) {
                        ag.getBase64GIF(function(image) {
                            callback({
                                'error': false,
                                'errorCode': '',
                                'errorMsg': '',
                                'image': image,
                                'cameraStream': cameraStream,
                                'videoElement': videoElement,
                                'webcamVideoElement': webcamVideoElement,
                                'savedRenderingContexts': renderingContextsToSave,
                                'keepCameraOn': keepCameraOn
                            });
                        });
                    }
                }
            };
            numFrames = numFrames !== undefined ? numFrames : 10;
            interval = interval !== undefined ? interval : 0.1; // In seconds
            canvas.width = gifWidth;
            canvas.height = gifHeight;
            context = canvas.getContext('2d');
            (function capture() {
                if (!savedRenderingContexts.length && videoElement.currentTime === 0) {
                    utils.requestTimeout(capture, 100);
                    return;
                }
                captureFrames();
            })();
        },
        getCropDimensions: function getCropDimensions() {
            var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var width = obj.videoWidth;
            var height = obj.videoHeight;
            var gifWidth = obj.gifWidth;
            var gifHeight = obj.gifHeight;
            var result = {
                width: 0,
                height: 0,
                scaledWidth: 0,
                scaledHeight: 0
            };
            if (width > height) {
                result.width = Math.round(width * (gifHeight / height)) - gifWidth;
                result.scaledWidth = Math.round(result.width * (height / gifHeight));
            } else {
                result.height = Math.round(height * (gifWidth / width)) - gifHeight;
                result.scaledHeight = Math.round(result.height * (width / gifWidth));
            }
            return result;
        }
    };
    /*
  videoStream.js
  ==============
*/ /* Copyright  2017 Yahoo Inc.
 * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.
*/ // Dependencies
    var videoStream = {
        loadedData: false,
        defaultVideoDimensions: {
            width: 640,
            height: 480
        },
        findVideoSize: function findVideoSizeMethod(obj) {
            findVideoSizeMethod.attempts = findVideoSizeMethod.attempts || 0;
            var cameraStream = obj.cameraStream, completedCallback = obj.completedCallback, videoElement = obj.videoElement;
            if (!videoElement) {
                return;
            }
            if (videoElement.videoWidth > 0 && videoElement.videoHeight > 0) {
                videoElement.removeEventListener('loadeddata', videoStream.findVideoSize);
                completedCallback({
                    videoElement: videoElement,
                    cameraStream: cameraStream,
                    videoWidth: videoElement.videoWidth,
                    videoHeight: videoElement.videoHeight
                });
            } else {
                if (findVideoSizeMethod.attempts < 10) {
                    findVideoSizeMethod.attempts += 1;
                    utils.requestTimeout(function() {
                        videoStream.findVideoSize(obj);
                    }, 400);
                } else {
                    completedCallback({
                        videoElement: videoElement,
                        cameraStream: cameraStream,
                        videoWidth: videoStream.defaultVideoDimensions.width,
                        videoHeight: videoStream.defaultVideoDimensions.height
                    });
                }
            }
        },
        onStreamingTimeout: function onStreamingTimeout(callback) {
            if (utils.isFunction(callback)) {
                callback({
                    error: true,
                    errorCode: 'getUserMedia',
                    errorMsg: 'There was an issue with the getUserMedia API - Timed out while trying to start streaming',
                    image: null,
                    cameraStream: {}
                });
            }
        },
        stream: function stream(obj) {
            var existingVideo = utils.isArray(obj.existingVideo) ? obj.existingVideo[0] : obj.existingVideo;
            var cameraStream = obj.cameraStream, completedCallback = obj.completedCallback, streamedCallback = obj.streamedCallback, videoElement = obj.videoElement;
            if (utils.isFunction(streamedCallback)) {
                streamedCallback();
            }
            if (existingVideo) {
                if (utils.isString(existingVideo)) {
                    videoElement.src = existingVideo;
                    videoElement.innerHTML = '<source src="' + existingVideo + '" type="video/' + utils.getExtension(existingVideo) + '" />';
                } else if (existingVideo instanceof Blob) {
                    try {
                        videoElement.src = utils.URL.createObjectURL(existingVideo);
                    } catch (e) {}
                    videoElement.innerHTML = '<source src="' + existingVideo + '" type="' + existingVideo.type + '" />';
                }
            } else if (videoElement.mozSrcObject) {
                videoElement.mozSrcObject = cameraStream;
            } else if (utils.URL) {
                try {
                    videoElement.srcObject = cameraStream;
                    videoElement.src = utils.URL.createObjectURL(cameraStream);
                } catch (e) {
                    videoElement.srcObject = cameraStream;
                }
            }
            videoElement.play();
            utils.requestTimeout(function checkLoadedData() {
                checkLoadedData.count = checkLoadedData.count || 0;
                if (videoStream.loadedData === true) {
                    videoStream.findVideoSize({
                        videoElement: videoElement,
                        cameraStream: cameraStream,
                        completedCallback: completedCallback
                    });
                    videoStream.loadedData = false;
                } else {
                    checkLoadedData.count += 1;
                    if (checkLoadedData.count > 10) {
                        videoStream.findVideoSize({
                            videoElement: videoElement,
                            cameraStream: cameraStream,
                            completedCallback: completedCallback
                        });
                    } else {
                        checkLoadedData();
                    }
                }
            }, 0);
        },
        startStreaming: function startStreaming(obj) {
            var errorCallback = utils.isFunction(obj.error) ? obj.error : utils.noop;
            var streamedCallback = utils.isFunction(obj.streamed) ? obj.streamed : utils.noop;
            var completedCallback = utils.isFunction(obj.completed) ? obj.completed : utils.noop;
            var crossOrigin = obj.crossOrigin, existingVideo = obj.existingVideo, lastCameraStream = obj.lastCameraStream, options = obj.options, webcamVideoElement = obj.webcamVideoElement;
            var videoElement = utils.isElement(existingVideo) ? existingVideo : webcamVideoElement ? webcamVideoElement : document1.createElement('video');
            var cameraStream = void 0;
            if (crossOrigin) {
                videoElement.crossOrigin = options.crossOrigin;
            }
            videoElement.autoplay = true;
            videoElement.loop = true;
            videoElement.muted = true;
            videoElement.addEventListener('loadeddata', function(event) {
                videoStream.loadedData = true;
                if (options.offset) {
                    videoElement.currentTime = options.offset;
                }
            });
            if (existingVideo) {
                videoStream.stream({
                    videoElement: videoElement,
                    existingVideo: existingVideo,
                    completedCallback: completedCallback
                });
            } else if (lastCameraStream) {
                videoStream.stream({
                    videoElement: videoElement,
                    cameraStream: lastCameraStream,
                    streamedCallback: streamedCallback,
                    completedCallback: completedCallback
                });
            } else {
                utils.getUserMedia({
                    video: true
                }, function(stream) {
                    videoStream.stream({
                        videoElement: videoElement,
                        cameraStream: stream,
                        streamedCallback: streamedCallback,
                        completedCallback: completedCallback
                    });
                }, errorCallback);
            }
        },
        startVideoStreaming: function startVideoStreaming(callback) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var timeoutLength = options.timeout !== undefined ? options.timeout : 0;
            var originalCallback = options.callback;
            var webcamVideoElement = options.webcamVideoElement;
            var noGetUserMediaSupportTimeout = void 0;
            // Some browsers apparently have support for video streaming because of the
            // presence of the getUserMedia function, but then do not answer our
            // calls for streaming.
            // So we'll set up this timeout and if nothing happens after a while, we'll
            // conclude that there's no actual getUserMedia support.
            if (timeoutLength > 0) {
                noGetUserMediaSupportTimeout = utils.requestTimeout(function() {
                    videoStream.onStreamingTimeout(originalCallback);
                }, 10000);
            }
            videoStream.startStreaming({
                error: function error() {
                    originalCallback({
                        error: true,
                        errorCode: 'getUserMedia',
                        errorMsg: 'There was an issue with the getUserMedia API - the user probably denied permission',
                        image: null,
                        cameraStream: {}
                    });
                },
                streamed: function streamed() {
                    // The streaming started somehow, so we can assume there is getUserMedia support
                    clearTimeout(noGetUserMediaSupportTimeout);
                },
                completed: function completed() {
                    var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                    var cameraStream = obj.cameraStream, videoElement = obj.videoElement, videoHeight = obj.videoHeight, videoWidth = obj.videoWidth;
                    callback({
                        cameraStream: cameraStream,
                        videoElement: videoElement,
                        videoHeight: videoHeight,
                        videoWidth: videoWidth
                    });
                },
                lastCameraStream: options.lastCameraStream,
                webcamVideoElement: webcamVideoElement,
                crossOrigin: options.crossOrigin,
                options: options
            });
        },
        stopVideoStreaming: function stopVideoStreaming(obj) {
            obj = utils.isObject(obj) ? obj : {};
            var _obj = obj, keepCameraOn = _obj.keepCameraOn, videoElement = _obj.videoElement, webcamVideoElement = _obj.webcamVideoElement;
            var cameraStream = obj.cameraStream || {};
            var cameraStreamTracks = cameraStream.getTracks ? cameraStream.getTracks() || [] : [];
            var hasCameraStreamTracks = !!cameraStreamTracks.length;
            var firstCameraStreamTrack = cameraStreamTracks[0];
            if (!keepCameraOn && hasCameraStreamTracks) {
                if (utils.isFunction(firstCameraStreamTrack.stop)) {
                    // Stops the camera stream
                    firstCameraStreamTrack.stop();
                }
            }
            if (utils.isElement(videoElement) && !webcamVideoElement) {
                // Pauses the video, revokes the object URL (freeing up memory), and remove the video element
                videoElement.pause();
                // Destroys the object url
                if (utils.isFunction(utils.URL.revokeObjectURL) && !utils.webWorkerError) {
                    if (videoElement.src) {
                        utils.URL.revokeObjectURL(videoElement.src);
                    }
                }
                // Removes the video element from the DOM
                utils.removeElement(videoElement);
            }
        }
    };
    /*
  stopVideoStreaming.js
  =====================
*/ /* Copyright  2017 Yahoo Inc.
 * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.
*/ function stopVideoStreaming(options) {
        options = utils.isObject(options) ? options : {};
        videoStream.stopVideoStreaming(options);
    }
    /*
  createAndGetGIF.js
  ==================
*/ /* Copyright  2017 Yahoo Inc.
 * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.
*/ // Dependencies
    function createAndGetGIF(obj, callback) {
        var options = obj.options || {};
        var images = options.images, video = options.video;
        var gifWidth = Number(options.gifWidth);
        var gifHeight = Number(options.gifHeight);
        var numFrames = Number(options.numFrames);
        var cameraStream = obj.cameraStream, videoElement = obj.videoElement, videoWidth = obj.videoWidth, videoHeight = obj.videoHeight;
        var cropDimensions = screenShot.getCropDimensions({
            videoWidth: videoWidth,
            videoHeight: videoHeight,
            gifHeight: gifHeight,
            gifWidth: gifWidth
        });
        var completeCallback = callback;
        options.crop = cropDimensions;
        options.videoElement = videoElement;
        options.videoWidth = videoWidth;
        options.videoHeight = videoHeight;
        options.cameraStream = cameraStream;
        if (!utils.isElement(videoElement)) {
            return;
        }
        videoElement.width = gifWidth + cropDimensions.width;
        videoElement.height = gifHeight + cropDimensions.height;
        if (!options.webcamVideoElement) {
            utils.setCSSAttr(videoElement, {
                position: 'fixed',
                opacity: '0'
            });
            document1.body.appendChild(videoElement);
        }
        // Firefox doesn't seem to obey autoplay if the element is not in the DOM when the content
        // is loaded, so we must manually trigger play after adding it, or the video will be frozen
        videoElement.play();
        screenShot.getGIF(options, function(obj) {
            if ((!images || !images.length) && (!video || !video.length)) {
                stopVideoStreaming(obj);
            }
            completeCallback(obj);
        });
    }
    /*
  existingVideo.js
  ================
*/ /* Copyright  2017 Yahoo Inc.
 * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.
*/ // Dependencies
    function existingVideo() {
        var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var callback = obj.callback, existingVideo = obj.existingVideo, options = obj.options;
        var skipObj = {
            getUserMedia: true,
            'window.URL': true
        };
        var errorObj = error.validate(skipObj);
        var loadedImages = 0;
        var videoType = void 0;
        var videoSrc = void 0;
        var tempImage = void 0;
        var ag = void 0;
        if (errorObj.error) {
            return callback(errorObj);
        }
        if (utils.isElement(existingVideo) && existingVideo.src) {
            videoSrc = existingVideo.src;
            videoType = utils.getExtension(videoSrc);
            if (!utils.isSupported.videoCodecs[videoType]) {
                return callback(error.messages.videoCodecs);
            }
        } else if (utils.isArray(existingVideo)) {
            utils.each(existingVideo, function(iterator, videoSrc) {
                if (videoSrc instanceof Blob) {
                    videoType = videoSrc.type.substr(videoSrc.type.lastIndexOf('/') + 1, videoSrc.length);
                } else {
                    videoType = videoSrc.substr(videoSrc.lastIndexOf('.') + 1, videoSrc.length);
                }
                if (utils.isSupported.videoCodecs[videoType]) {
                    existingVideo = videoSrc;
                    return false;
                }
            });
        }
        videoStream.startStreaming({
            completed: function completed(obj) {
                obj.options = options || {};
                createAndGetGIF(obj, callback);
            },
            existingVideo: existingVideo,
            crossOrigin: options.crossOrigin,
            options: options
        });
    }
    /*
  existingWebcam.js
  =================
*/ /* Copyright  2017 Yahoo Inc.
 * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.
*/ // Dependencies
    function existingWebcam() {
        var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var callback = obj.callback, lastCameraStream = obj.lastCameraStream, options = obj.options, webcamVideoElement = obj.webcamVideoElement;
        if (!isWebCamGIFSupported()) {
            return callback(error.validate());
        }
        if (options.savedRenderingContexts.length) {
            screenShot.getGIF(options, function(obj) {
                callback(obj);
            });
            return;
        }
        videoStream.startVideoStreaming(function() {
            var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            obj.options = options || {};
            createAndGetGIF(obj, callback);
        }, {
            lastCameraStream: lastCameraStream,
            callback: callback,
            webcamVideoElement: webcamVideoElement,
            crossOrigin: options.crossOrigin
        });
    }
    /*
  createGIF.js
  ============
*/ /* Copyright  2017 Yahoo Inc.
 * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.
*/ // Dependencies
    function createGIF(userOptions, callback) {
        callback = utils.isFunction(userOptions) ? userOptions : callback;
        userOptions = utils.isObject(userOptions) ? userOptions : {};
        if (!utils.isFunction(callback)) {
            return;
        }
        var options = utils.mergeOptions(defaultOptions, userOptions) || {};
        var lastCameraStream = userOptions.cameraStream;
        var images = options.images;
        var imagesLength = images ? images.length : 0;
        var video = options.video;
        var webcamVideoElement = options.webcamVideoElement;
        options = utils.mergeOptions(options, {
            'gifWidth': Math.floor(options.gifWidth),
            'gifHeight': Math.floor(options.gifHeight)
        });
        // If the user would like to create a GIF from an existing image(s)
        if (imagesLength) {
            existingImages({
                'images': images,
                'imagesLength': imagesLength,
                'callback': callback,
                'options': options
            });
        } else if (video) {
            // If the user would like to create a GIF from an existing HTML5 video
            existingVideo({
                'existingVideo': video,
                callback: callback,
                options: options
            });
        } else {
            // If the user would like to create a GIF from a webcam stream
            existingWebcam({
                lastCameraStream: lastCameraStream,
                callback: callback,
                webcamVideoElement: webcamVideoElement,
                options: options
            });
        }
    }
    /*
  takeSnapShot.js
  ===============
*/ /* Copyright  2017 Yahoo Inc.
 * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.
*/ function takeSnapShot(userOptions, callback) {
        callback = utils.isFunction(userOptions) ? userOptions : callback;
        userOptions = utils.isObject(userOptions) ? userOptions : {};
        if (!utils.isFunction(callback)) {
            return;
        }
        var mergedOptions = utils.mergeOptions(defaultOptions, userOptions);
        var options = utils.mergeOptions(mergedOptions, {
            'interval': .1,
            'numFrames': 1,
            'gifWidth': Math.floor(mergedOptions.gifWidth),
            'gifHeight': Math.floor(mergedOptions.gifHeight)
        });
        createGIF(options, callback);
    }
    /*
  API.js
  ======
*/ /* Copyright  2017 Yahoo Inc.
 * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.
*/ // Dependencies
    var API = {
        'utils': utils$2,
        'error': error$2,
        'defaultOptions': defaultOptions$2,
        'createGIF': createGIF,
        'takeSnapShot': takeSnapShot,
        'stopVideoStreaming': stopVideoStreaming,
        'isSupported': isSupported,
        'isWebCamGIFSupported': isWebCamGIFSupported,
        'isExistingVideoGIFSupported': isExistingVideoGIFSupported,
        'isExistingImagesGIFSupported': isSupported$1,
        'VERSION': '0.4.5'
    };
    /*
  index.js
  ========
*/ /* Copyright  2017 Yahoo Inc.
 * Copyrights licensed under the MIT License. See the accompanying LICENSE file for terms.
 */ // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, and plain browser loading
    if (typeof define === 'function' && define.amd) {
        ((r)=>r !== undefined && __turbopack_context__.v(r))(function() {
            return API;
        }());
    } else if ("TURBOPACK compile-time truthy", 1) {
        module.exports = API;
    } else {
        "TURBOPACK unreachable";
    }
})(typeof window !== "undefined" ? window : {}, typeof document !== "undefined" ? document : {
    createElement: function() {}
}, typeof window !== "undefined" ? window.navigator : {});
}}),
}]);

//# sourceMappingURL=node_modules_bb63621b._.js.map